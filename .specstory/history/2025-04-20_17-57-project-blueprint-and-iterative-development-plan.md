<!-- Generated by SpecStory -->

# Project Blueprint and Iterative Development Plan (2025-04-20 10:57:17)

_**User**_

@spec.md raft a detailed, step-by-step blueprint for building this project. Then, once you have a solid plan, break it down into small, iterative chunks that build on each other. Look at these chunks and then go another round to break it into small steps. Review the results and make sure that the steps are small enough to be implemented safely with strong testing, but big enough to move the project forward. Iterate until you feel that the steps are right sized for this project.

From here you should have the foundation to provide a series of prompts for a code-generation LLM that will implement each step in a test-driven manner. Prioritize best practices, incremental progress, and early testing, ensuring no big jumps in complexity at any stage. Make sure that each prompt builds on the previous prompts, and ends with wiring things together. There should be no hanging or orphaned code that isn't integrated into a previous step.

Make sure and separate each prompt section. Use markdown. Each prompt should be tagged as text using code tags. The goal is to output prompts, but context, etc is important as well.

---

_**Assistant**_



---

Okay, Big D, let's craft a blueprint and generate those LLM prompts based on `spec.md`.

First, I need to read the specification to ensure I understand all the requirements.



---

Read file: spec.md

---

Okay, Big D, I've reviewed the spec. Here is the iterative blueprint and the corresponding LLM prompts.

## Project Blueprint: Cloud-Hosted Aider via Discord

This blueprint breaks the project down into small, testable, iterative steps. Each step builds upon the previous ones.

**Phase 1: Core Bot & Data Setup**

1.  **Basic Bot Connection:** Set up a minimal Node.js Discord bot that connects using `discord.js` and responds to a simple `/ping` command.
    *   *Test:* Bot connects, logs in, and replies "Pong!" to `/ping`.
2.  **MongoDB Connection:** Integrate `mongodb` driver. Add basic configuration (env var for connection string) and a connection module that handles connecting and provides the DB client.
    *   *Test:* Bot connects to MongoDB successfully on startup. Basic connection tests pass.
3.  **Repository Schema & Model:** Define the Mongoose schema for the `repositories` collection (initially just `_id`, `repoUrl`, `discordChannelId`). Create a simple model file.
    *   *Test:* Can create and retrieve a basic repository document using the model.
4.  **`/add-repo` Command Stub:** Implement the `/add-repo` slash command structure. Initially, it only needs to parse the `url` argument and acknowledge receipt. Ensure it's admin-only (check user permissions).
    *   *Test:* Command registers, only admins can run it, it acknowledges the provided URL.
5.  **Store Repo Info:** Enhance `/add-repo` to store the `repoUrl` and the current `channelId` in the `repositories` collection using the model from Step 3.
    *   *Test:* Running `/add-repo` creates a new document in the `repositories` collection with the correct URL and channel ID.

**Phase 2: Basic Python Wrapper & Invocation**

6.  **Python Wrapper Stub (`aider_wrapper.py`):** Create a basic Python script that accepts a `--prompt` argument and prints a predefined JSON output to stdout (e.g., `{"overall_status": "success", "events": [{"type": "text_response", "content": "Placeholder response"}]}`). Include basic argument parsing (`argparse`).
    *   *Test:* Running `python3 aider_wrapper.py --prompt "test"` prints the expected JSON.
7.  **Node.js Wrapper Invocation:** Create a Node.js module to spawn the `aider_wrapper.py` script using `child_process.spawn`. Capture `stdout` and `stderr`. Pass the user's prompt via the `--prompt` argument.
    *   *Test:* Node function successfully calls the Python script, passes the prompt, and captures the predefined JSON output and any stderr.
8.  **`@mention` Handling:** Implement logic to detect when the bot is mentioned (`messageCreate` event). Parse the message content as the prompt. Use the channel ID to look up the corresponding repository configuration (from Step 5). If found, invoke the Python wrapper (from Step 7).
    *   *Test:* Mentioning the bot in a configured channel triggers the Python script with the message content as the prompt.
9.  **Basic Output Parsing & Display:** Parse the JSON output from the Python wrapper. If `overall_status` is "success", format and send the `text_response` content back to the Discord channel. Handle basic script errors (`overall_status: "failure"` or non-zero exit code).
    *   *Test:* Bot replies with the placeholder text from the wrapper script upon successful invocation. Bot reports a generic error if the script fails.

**Phase 3: Context File Management**

10. **Update Repo Schema for Context:** Add `contextFiles: [String]` to the `repositories` schema/model.
    *   *Test:* Schema validation passes, can update documents with `contextFiles`.
11. **`/add`, `/drop`, `/files` Commands:** Implement these slash commands.
    *   `/add`: Takes file path(s), validates them minimally (e.g., not absolute paths), adds them to the `contextFiles` array in the DB for the current channel's repo.
    *   `/drop`: Takes file path(s), removes them from the `contextFiles` array.
    *   `/files`: Retrieves and displays the current `contextFiles` list from the DB.
    *   *Test:* Commands update/retrieve the `contextFiles` array in the DB correctly for the specific channel.
12. **Pass Context Files to Wrapper:** Modify the Node.js wrapper invocation (Step 7) to retrieve the `contextFiles` for the repo. Modify `aider_wrapper.py` (Step 6) to accept multiple `--context-file` arguments. Pass the retrieved file paths to the script.
    *   *Test:* Python script receives the correct `--context-file` arguments based on the DB state.

**Phase 4: SSH Key Handling & Security**

13. **Encryption Helpers:** Create a Node.js module with functions to encrypt and decrypt strings using AES (from `node:crypto`) based on a master `ENCRYPTION_KEY` environment variable.
    *   *Test:* Unit tests verify that text encrypted can be successfully decrypted using the same key.
14. **Update Repo Schema for SSH Key:** Add `encryptedSshKey: String` to the `repositories` schema/model.
    *   *Test:* Schema validation passes.
15. **Extend `/add-repo` for SSH Key:** Modify `/add-repo` (Step 5) to require an `ssh_key` attachment. Read the attachment content, encrypt it using the helper (Step 13), and store it in `encryptedSshKey`.
    *   *Test:* `/add-repo` successfully stores the encrypted key content in the DB.
16. **Secure Temp Key Handling:** Create Node.js functions to:
    *   Take an assigned user ID (e.g., `coder1`) and repo name.
    *   Create a temporary directory if needed (`/repos/<repo_name>/.ssh/`).
    *   Write decrypted key content to a temporary file (`/repos/<repo_name>/.ssh/id_rsa`) owned by the assigned user with `600` permissions (requires `fs.writeFile` and potentially `child_process.exec` for `chown`/`chmod` if running as root initially, *or* rely on `sudo` later).
    *   Securely delete the temporary key file.
    *   *Test:* Functions correctly create/delete the file with expected content and permissions (may require mocking fs/child_process or running tests in a suitable environment). *Initially, skip user ownership if not running as root.*
17. **Pass SSH Info to Wrapper:** Modify the wrapper invocation (Step 12) to:
    *   Retrieve the encrypted key, decrypt it.
    *   Call the function to write the temporary key file (Step 16).
    *   Construct the `GIT_SSH_COMMAND` string (pointing to the temp key, disabling strict host checking).
    *   Pass `GIT_SSH_COMMAND` as an environment variable to the spawned Python process.
    *   Ensure the temporary key file is deleted *after* the process exits (use `finally` block).
    *   *Test:* Python script receives the `GIT_SSH_COMMAND` environment variable. Temp key file is created before spawn and deleted after.

**Phase 5: Docker, Isolation & Basic Git**

18. **Dockerfile Setup:** Create a `Dockerfile` with:
    *   Base image (e.g., Node + Python).
    *   Install `git`, `sudo`, `tree`.
    *   Install Node.js app dependencies (`npm install`).
    *   Install Python dependencies (`pip install aider-chat`).
    *   Copy application code.
    *   *Test:* Docker image builds successfully.
19. **User Creation & `sudo`:** Modify `Dockerfile` to:
    *   Create a non-root `appuser`.
    *   Create a pool of `coderX` users (e.g., `coder1` to `coder5`).
    *   Configure `/etc/sudoers` to allow `appuser` passwordless execution of specific commands (`python3 /path/to/aider_wrapper.py`, `git`, `rm`, `mkdir`, `chown`, `chmod`) as any `coderX` user.
    *   Set `USER appuser`.
    *   Define `/repos` volume/directory.
    *   *Test:* Run container, exec as `appuser`, verify `sudo -u coder1 whoami` works for allowed commands, fails for others. Verify `/repos` exists.
20. **Assign User & Update Schema:** Add `assignedUserId: String` to the `repositories` schema. Modify `/add-repo` to select an available `coderX` user ID (e.g., round-robin or find first unused) and store it.
    *   *Test:* `/add-repo` assigns a `coderX` user ID to the new repo document.
21. **Run Wrapper as Assigned User:** Modify the wrapper invocation (Step 17) to:
    *   Use `sudo -u <assignedUserId> python3 ...` for the command.
    *   Set the `cwd` (current working directory) for the spawned process to `/repos/<repo_name>`.
    *   Pass the decrypted SSH key to the temp file handler (Step 16) along with the assigned user ID so it can set ownership correctly (now using `sudo -u <user> chown/chmod` if needed, or directly writing if `appuser` has sudo rights to write as `coderX`). Ensure `/repos/<repo_name>` exists and is owned by `assignedUserId`. `/add-repo` might need to create this dir.
    *   *Test:* Wrapper script executes as the correct `coderX` user within the designated repo directory. Temporary key file is created with correct ownership/permissions.
22. **Basic Git Clone in `/add-repo`:** After storing repo info and assigning a user, `/add-repo` should now:
    *   Create `/repos/<repo_name>` directory, `chown` to `assignedUserId`.
    *   Write the temporary SSH key.
    *   Execute `git clone <repoUrl> .` within `/repos/<repo_name>` using `sudo -u <assignedUserId>` and the `GIT_SSH_COMMAND` environment variable.
    *   Delete the temporary key.
    *   *Test:* `/add-repo` successfully clones the target repository into the correct directory owned by the assigned user.

**Phase 6: Aider Integration & Git Operations**

23. **Integrate `aider` in Wrapper:** Modify `aider_wrapper.py` (Step 12) to:
    *   Import `aider.coders`.
    *   Initialize `aider.coders.Coder` (non-interactive: `InputOutput(yes=True)`, provide context files `fnames`).
    *   Run the coder: `coder.run(prompt)`.
    *   (Initially) Capture basic output/status. Define the JSON output structure from `spec.md` (6.5). Populate `overall_status` and basic `text_response` or `error`.
    *   *Test:* Wrapper script successfully initializes and runs the `aider` Coder (can mock `coder.run`). Produces basic JSON output.
24. **Detect File Changes:** Enhance `aider_wrapper.py` to inspect the state *after* `coder.run()` to identify added/modified/deleted files relative to the Git HEAD before the run. Populate the `file_change` events in the JSON output, including `filename`, `change_type`, and potentially `content` or `diff`.
    *   *Test:* Wrapper correctly identifies mock file changes and includes them in the JSON output.
25. **Implement Auto Git Commit/Push:** Enhance the *Node.js* bot logic (after Step 9's output parsing):
    *   If the wrapper JSON indicates success *and* contains `file_change` events:
        *   Spawn `git add .` using `sudo -u <assignedUserId>`, `cwd`, env.
        *   Spawn `git commit -m "Aider commit based on user prompt"` using `sudo`, `cwd`, env.
        *   Spawn `git push origin HEAD:aider/channel-<channelId>` using `sudo`, `cwd`, env. (Ensure branch name is safe).
    *   *Test:* Successful `aider` run with file changes triggers the git add/commit/push sequence.

**Phase 7: Queueing & History**

26. **Task Queue Schema & Model:** Define MongoDB schema/model for `task_queues` (`channelId`, `queue: [{ userId, commandType, commandData, timestamp }]`).
    *   *Test:* Can create/update queue documents.
27. **Implement Queue Logic:** Create a queue manager module in Node.js.
    *   `enqueue(channelId, taskData)`: Adds task to the queue array in MongoDB.
    *   `dequeue(channelId)`: Removes and returns the oldest task.
    *   `peek(channelId)`: Returns the oldest task without removing.
    *   A processing loop/mechanism: Checks queues periodically or via trigger. If a queue has tasks and isn't already processing, dequeue and process the next task for that `channelId`. Maintain an in-memory set of `activeChannelIds`.
    *   *Test:* Unit tests for enqueue, dequeue, peek. Test processing loop handles sequential execution per channel.
28. **Integrate Queue:** Modify `@mention` handler (Step 8) and potentially other command handlers:
    *   Instead of immediate execution, `enqueue` the request.
    *   Inform the user their request is queued if the queue isn't empty or processing is active for the channel.
    *   The processing loop (Step 27) will now trigger the wrapper invocation (Step 21) and subsequent steps (output parsing, git commit).
    *   *Test:* Multiple requests for the same channel are processed sequentially. Bot informs users about queue status.
29. **Message History Schema & Model:** Define MongoDB schema/model for `message_history` (`channelId`, `messageId`, `authorId`, `timestamp`, `content`, `type`).
    *   *Test:* Can create/retrieve history documents.
30. **Store History:** Store user prompts (`@mention` content) and summarized bot responses (e.g., `text_response` from `aider`) in the `message_history` collection after processing.
    *   *Test:* Relevant messages are stored in the DB associated with the correct channel.
31. **Retrieve & Pass History:** Before invoking the Python wrapper (within the queue processing logic), retrieve recent N messages from `message_history` for the `channelId`. Format them into a simple transcript string. Modify `aider_wrapper.py` to accept history via stdin or a `--history` argument. Pass the transcript.
    *   *Test:* Wrapper script receives formatted history.

**Phase 8: Additional Commands & Polish**

32. **`/ls` & `/tree` Commands:** Implement these commands. They need to execute `ls` or `tree` within the `/repos/<repo_name>` directory using `sudo -u <assignedUserId>`. Capture output and send to Discord.
    *   *Test:* Commands display file/directory listings correctly.
33. **`/diff` Command:** Implement `/diff`. Execute `git diff HEAD~1..HEAD` (or similar to get the last bot commit) using `sudo`, `cwd`, env. Send output as a `.diff` file attachment.
    *   *Test:* Command shows the diff of the last commit made by the bot.
34. **`/clear` Command:** Implement `/clear`. Delete relevant `message_history` for the channel. Reset `contextFiles` in the `repositories` document. Potentially reset `aider`'s internal state if possible/needed (might involve calling `aider` with a specific command via the wrapper).
    *   *Test:* History and context files are cleared in the DB.
35. **Refine Error Handling & Logging:** Add more specific error handling and logging throughout the Node.js bot and Python script based on `spec.md` Section 7. Ensure sensitive info is not leaked.
    *   *Test:* Different error scenarios (Git failure, script crash, DB error) are handled gracefully, logged appropriately, and reported clearly to the user.
36. **Autocomplete:** Implement autocomplete providers for `/add`, `/drop`, `/ls`, `/tree` by reading the relevant directory contents (`ls` via `sudo`) when Discord requests suggestions. Handle potential errors/timeouts gracefully.
    *   *Test:* Autocomplete suggests relevant files/directories from the repo.
37. **`/undo` Command:** Implement `/undo`. Execute `git revert HEAD --no-edit` and `git push` using `sudo`, `cwd`, env. Requires careful state management to know *what* to revert.
    *   *Test:* Command successfully reverts the last bot commit and pushes the change.

---

## LLM Prompts for Implementation

Here are the prompts corresponding to the blueprint steps, Big D.

**Prompt 1: Basic Bot Connection**

```text
Task: Create a basic Node.js Discord bot using discord.js v14.
Requirements:
1.  Initialize a new Node.js project (`npm init -y`, add `discord.js`).
2.  Create an entry point file (`index.js` or `bot.js`).
3.  Use environment variables for the Discord Bot Token (`DISCORD_TOKEN`). Use `dotenv` package.
4.  Implement basic login logic to connect the bot to Discord.
5.  Register a simple slash command `/ping`.
6.  Implement an interaction handler that replies "Pong!" to the `/ping` command.
7.  Include a basic `README.md` explaining setup (install deps, create `.env` with token, run `node .`).
8.  Use standard.js style. Add `standard` as a dev dependency and include a lint script in `package.json`. Run `standard --fix`.
9.  Add basic logging for 'ready' and 'interactionCreate' events.
Testing:
-   Create a `test/ping.test.js` using `tape`.
-   The test should ideally mock the Discord client or parts of it to verify command registration and response logic without actually connecting to Discord. Focus on testing the handler logic.
-   Ensure tests run via `npm test` and exit cleanly.
```

**Prompt 2: MongoDB Connection**

```text
Task: Integrate MongoDB connection logic into the bot from Prompt 1.
Requirements:
1.  Add the `mongodb` npm package.
2.  Create a configuration file/module (`config.js`) that reads `MONGODB_URI` and `MONGODB_DB_NAME` from environment variables (`.env`).
3.  Create a database connection module (`db.js` or `lib/mongo.js`).
    -   It should export an async function `connectDB` that connects to MongoDB using the URI from config.
    -   It should handle connection errors gracefully (log and potentially exit).
    -   It should store the connected client or db instance for reuse.
    -   It should export a function `getDB` to retrieve the db instance.
4.  Call `connectDB` in the main bot file (`index.js`) after login, before starting command handling. Ensure the bot waits for the connection before proceeding.
5.  Use standard.js style. Run `standard --fix`.
Testing:
-   Create `test/db.test.js` using `tape`.
-   Use `mongodb-memory-server` (add as dev dependency) to spin up an in-memory MongoDB for testing.
-   Test that `connectDB` successfully connects to the in-memory server.
-   Test that `getDB` returns a valid DB instance after connection.
-   Ensure tests run via `npm test` and exit cleanly.
```

**Prompt 3: Repository Schema & Model**

```text
Task: Define a MongoDB schema and model for repositories.
Requirements:
1.  Add the `mongoose` npm package (although `mongodb` driver is already added, Mongoose simplifies schema definition and validation, let's use it for models).
2.  Modify `db.js` (from Prompt 2) to use `mongoose.connect` instead of the raw driver connection, or adapt it to work alongside the driver if preferred (keep it simple, maybe replace raw driver usage). Ensure `getDB` still works or adapt dependent code.
3.  Create a `models/Repository.js` file.
4.  Define a Mongoose schema `repositorySchema` with the following fields initially:
    -   `repoUrl`: { type: String, required: true }
    -   `discordChannelId`: { type: String, required: true, unique: true } // Assuming one repo per channel
5.  Create and export the Mongoose model: `mongoose.model('Repository', repositorySchema)`.
6.  Use standard.js style. Run `standard --fix`.
Testing:
-   Create `test/repository.model.test.js` using `tape`.
-   Connect to the in-memory MongoDB server.
-   Test creating a new repository document using the model. Check for validation errors (e.g., missing `repoUrl`).
-   Test retrieving a saved document.
-   Ensure tests run via `npm test` and exit cleanly, disconnecting Mongoose properly (`mongoose.connection.close()`).
```

**Prompt 4: `/add-repo` Command Stub**

```text
Task: Implement a stub for the `/add-repo` slash command.
Requirements:
1.  Modify the bot's command registration logic (likely from Prompt 1) to register a new slash command `/add-repo`.
2.  The command should have one required string option: `url`.
3.  Modify the interaction handler:
    -   Check if the interaction `commandName` is `add-repo`.
    -   Check if the user invoking the command has Administrator permissions (`interaction.member.permissions.has(PermissionsBitField.Flags.Administrator)`). If not, reply with an error message and return.
    -   If admin, retrieve the value of the `url` option.
    -   Reply with a temporary acknowledgement message like "Received request to add repo: [URL]".
4.  Use standard.js style. Run `standard --fix`.
Testing:
-   Create `test/add-repo-command.test.js` using `tape`.
-   Mock the `interaction` object.
-   Test that non-admins receive a permission error reply.
-   Test that admins receive the acknowledgement reply, including the passed URL.
-   Verify the handler correctly identifies the command and extracts the option.
-   Ensure tests run via `npm test`.
```

**Prompt 5: Store Repo Info**

```text
Task: Enhance the `/add-repo` command to store repository information in MongoDB.
Requirements:
1.  Modify the `/add-repo` command handler (from Prompt 4).
2.  After checking admin permissions and retrieving the `url`:
    -   Get the `channelId` from the `interaction` object (`interaction.channelId`).
    -   Import the `Repository` model (from Prompt 3).
    -   Use the model to create or update (upsert might be suitable, or find-and-update) a document in the `repositories` collection. Store the `repoUrl` and `discordChannelId`. Handle potential database errors (e.g., duplicate channel ID if not using upsert).
    -   Reply to the user confirming the repository configuration has been saved (e.g., "Repository configuration for [URL] saved for this channel."). Include error reporting if the save fails.
3.  Use standard.js style. Run `standard --fix`.
Testing:
-   Modify `test/add-repo-command.test.js` or create a new test file.
-   Use the in-memory MongoDB server.
-   Mock the `interaction` object with admin permissions, a channel ID, and a URL.
-   After simulating the command execution, assert that a corresponding document exists in the database with the correct `repoUrl` and `discordChannelId`.
-   Test error handling for database failures (e.g., mock the model's save/update method to throw an error).
-   Ensure tests run via `npm test` and the database is clean after tests.
```

**(Continue generating prompts for steps 6-37 in a similar fashion, ensuring each builds on the previous, includes testing requirements, and follows the specified conventions.)**

---

This provides the initial set of steps and prompts, Big D. Let me know when you're ready for the next batch!

---

_**User**_

dont be lazy no stopping until fullt done

---

_**Assistant**_



---

You got it, Big D. No slacking here. Let's continue generating the prompts for the rest of the blueprint.

**Prompt 6: Python Wrapper Stub (`aider_wrapper.py`)**

```text
Task: Create a basic Python script (`aider_wrapper.py`) that acts as a placeholder for the real `aider` interaction.
Requirements:
1.  Create the file `aider_wrapper.py` in the project root or a suitable subdirectory (e.g., `scripts/`).
2.  Use Python's `argparse` module to accept one command-line argument: `--prompt`.
3.  Use Python's `json` module.
4.  The script should parse the arguments.
5.  The script should print a JSON object to standard output with the following structure:
    ```json
    {
      "overall_status": "success",
      "error": null,
      "events": [
        {
          "type": "text_response",
          "content": "Placeholder response for prompt: [PROMPT_VALUE]"
        }
      ]
    }
    ```
    Replace `[PROMPT_VALUE]` with the actual value received from the `--prompt` argument.
6.  If the `--prompt` argument is missing, it should print an error message to stderr and exit with a non-zero status code.
7.  Ensure the script is executable (`chmod +x aider_wrapper.py`).
Testing:
-   Create `test/aider_wrapper.test.js` (Node.js test file using `tape` and `child_process`).
-   Test running the Python script as a child process from Node.js.
-   Test case 1: Provide `--prompt "hello"`. Assert that the child process exits with code 0 and stdout contains the expected JSON structure with the correct placeholder text.
-   Test case 2: Run without `--prompt`. Assert that the child process exits with a non-zero code and stderr contains an error message.
-   Ensure tests run via `npm test`.
```

**Prompt 7: Node.js Wrapper Invocation**

```text
Task: Create a Node.js module to spawn and manage the `aider_wrapper.py` script.
Requirements:
1.  Create a new file, e.g., `lib/pythonWrapper.js`.
2.  This module should export an async function, e.g., `invokeAiderWrapper({ prompt })`.
3.  Inside this function:
    -   Use `child_process.spawn` to execute the `aider_wrapper.py` script (using `python3`).
    -   Pass the `prompt` value using the `--prompt` argument.
    -   Capture `stdout` and `stderr` streams.
    -   Wait for the process to exit.
    -   If the exit code is non-zero or `stderr` is not empty, return an error object (e.g., `{ status: 'failure', error: stderrContent, stdout: stdoutContent }`).
    -   If the exit code is 0, parse the `stdout` content as JSON.
    -   If JSON parsing fails, return an error object.
    -   If JSON parsing succeeds, return the parsed object (e.g., `{ status: 'success', data: parsedJson }`).
4.  Handle potential errors during process spawning itself (e.g., script not found).
5.  Use standard.js style. Run `standard --fix`.
Testing:
-   Create `test/pythonWrapper.test.js` using `tape`.
-   Test the `invokeAiderWrapper` function.
-   Test case 1 (Success): Call with a prompt. Assert that the function returns the expected success object containing the parsed JSON from the stub script (Prompt 6).
-   Test case 2 (Script Error): Modify the test to make the script exit non-zero (e.g., by not passing `--prompt`). Assert that the function returns a failure object with the captured stderr.
-   Test case 3 (Spawn Error): Mock `child_process.spawn` to throw an error. Assert the function handles it gracefully.
-   Test case 4 (JSON Parse Error): Modify the test script to output invalid JSON. Assert the function returns a failure object indicating a parse error.
-   Ensure tests run via `npm test`.
```

**Prompt 8: `@mention` Handling**

```text
Task: Implement logic to handle bot mentions and trigger the Python wrapper.
Requirements:
1.  In the main bot file (`index.js`), add a handler for the `messageCreate` event from `discord.js`.
2.  Inside the handler:
    -   Ignore messages from bots (including itself).
    -   Check if the bot was mentioned in the message content (`message.mentions.has(client.user)`).
    -   If mentioned, extract the message content, removing the mention itself to get the user's prompt string. Trim whitespace.
    -   Get the `channelId` from the message (`message.channelId`).
    -   Import the `Repository` model (Prompt 3). Query the database to find a repository document matching the `channelId`.
    -   If no repository is found for the channel, reply politely indicating the channel isn't configured and return.
    -   If a repository is found:
        -   Import and call the `invokeAiderWrapper` function (Prompt 7) with the extracted prompt.
        -   (For now, just log the result or error. Output display will be in the next step).
3.  Ensure the bot has the necessary Intents enabled (e.g., `GatewayIntentBits.Guilds`, `GatewayIntentBits.GuildMessages`, `GatewayIntentBits.MessageContent`). Update the client initialization if needed. Remember `MessageContent` is privileged.
4.  Use standard.js style. Run `standard --fix`.
Testing:
-   Create `test/mentionHandler.test.js` using `tape`.
-   Use the in-memory MongoDB. Seed it with a test repository document.
-   Mock the `message` object and `client.user`.
-   Test case 1 (No Mention): Simulate a message without mentioning the bot. Assert the wrapper is *not* called.
-   Test case 2 (Mention, No Repo): Simulate a mention in a channel *not* in the DB. Assert the wrapper is *not* called and a specific reply is sent.
-   Test case 3 (Mention, Repo Found): Simulate a mention in a channel *with* a configured repo. Assert that `invokeAiderWrapper` is called with the correctly extracted prompt. Mock `invokeAiderWrapper` to verify it's called.
-   Ensure tests run via `npm test`.
```

**Prompt 9: Basic Output Parsing & Display**

```text
Task: Parse the output from the Python wrapper and display the response in Discord.
Requirements:
1.  Modify the `messageCreate` handler (from Prompt 8).
2.  After receiving the result from `invokeAiderWrapper`:
    -   Check the `status` field of the result.
    -   If `status` is 'failure', reply to the original message with a generic error (e.g., "‚ùå An error occurred while processing your request. Details logged."). Log the detailed error (`result.error`, `result.stdout`) internally.
    -   If `status` is 'success':
        -   Access the parsed JSON data (`result.data`).
        -   Check `result.data.overall_status`. If it's 'failure', report an error similar to the above, logging `result.data.error`.
        -   If `result.data.overall_status` is 'success':
            -   Find the first event with `type: "text_response"` in the `result.data.events` array.
            -   If found, reply to the original message with the `content` of that event.
            -   If no `text_response` event is found, reply with a message indicating success but no text output.
3.  Handle potential network errors when replying to Discord.
4.  Use standard.js style. Run `standard --fix`.
Testing:
-   Modify `test/mentionHandler.test.js`.
-   Mock `invokeAiderWrapper` to return different results:
    -   Success case: Return the standard placeholder JSON. Assert that `message.reply` is called with the correct placeholder text.
    -   Wrapper failure case: Return `{ status: 'failure', error: 'stderr output' }`. Assert `message.reply` is called with a generic error message.
    -   Script failure case: Return `{ status: 'success', data: { overall_status: 'failure', error: 'script error', events: [] } }`. Assert `message.reply` is called with a generic error message.
    -   No text response case: Return `{ status: 'success', data: { overall_status: 'success', events: [] } }`. Assert `message.reply` is called with an appropriate message.
-   Mock `message.reply` to verify its arguments and prevent actual Discord calls.
-   Ensure tests run via `npm test`.
```

**Prompt 10: Update Repo Schema for Context**

```text
Task: Add the `contextFiles` field to the Repository schema.
Requirements:
1.  Modify `models/Repository.js` (from Prompt 3).
2.  Add a new field to the `repositorySchema`:
    -   `contextFiles`: { type: [String], default: [] }
3.  Ensure existing model usage is not broken (Mongoose should handle the default).
4.  Use standard.js style. Run `standard --fix`.
Testing:
-   Modify `test/repository.model.test.js` (from Prompt 3).
-   Test creating a new repository document. Assert that `contextFiles` exists and is an empty array by default.
-   Test updating an existing document to add file paths to `contextFiles`. Assert the update is successful.
-   Ensure tests run via `npm test`.
```

**Prompt 11: `/add`, `/drop`, `/files` Commands**

```text
Task: Implement slash commands for managing context files.
Requirements:
1.  Register three new slash commands:
    -   `/files`: No options.
    -   `/add`: One required string option `paths` (Description: Space-separated file paths).
    -   `/drop`: One required string option `paths` (Description: Space-separated file paths).
2.  In the interaction handler:
    -   Handle `files` command:
        -   Find the repository document for the `interaction.channelId`. If none, reply error.
        -   Retrieve the `contextFiles` array.
        -   Reply with the list of files, nicely formatted (e.g., in a code block or numbered list), or "No files currently in context."
    -   Handle `add` command:
        -   Find the repository document for the `interaction.channelId`. If none, reply error.
        -   Get the `paths` string option. Split it by spaces to get an array of potential file paths. Filter out empty strings.
        -   Perform basic validation (e.g., reject paths starting with `/` or containing `..`). Reply with error for invalid paths.
        -   Update the repository document by adding the valid new paths to the `contextFiles` array (avoid duplicates). Use MongoDB's `$addToSet` with `$each`.
        -   Reply confirming which files were added.
    -   Handle `drop` command:
        -   Find the repository document for the `interaction.channelId`. If none, reply error.
        -   Get the `paths` string option. Split it by spaces.
        -   Update the repository document by removing the specified paths from the `contextFiles` array. Use MongoDB's `$pull` with `$in`.
        -   Reply confirming which files were removed (or indicate if they weren't found).
3.  Use standard.js style. Run `standard --fix`.
Testing:
-   Create `test/contextCommands.test.js` using `tape`.
-   Use in-memory MongoDB. Seed with a test repository.
-   Mock the `interaction` object for each command.
-   Test `/files`: Assert the reply contains the expected files from the seeded document.
-   Test `/add`: Assert the DB document is updated correctly (files added, duplicates ignored). Test validation rejects bad paths. Verify reply message.
-   Test `/drop`: Assert the DB document is updated correctly (files removed). Verify reply message.
-   Test commands fail gracefully if no repo is configured for the channel.
-   Mock `interaction.reply`.
-   Ensure tests run via `npm test`.
```

**Prompt 12: Pass Context Files to Wrapper**

```text
Task: Pass the stored context files to the Python wrapper script.
Requirements:
1.  Modify `aider_wrapper.py` (from Prompt 6):
    -   Use `argparse` to accept multiple occurrences of a `--context-file` argument (`action='append'`).
    -   Include the received context file paths in the JSON output for verification (e.g., add a field like `"received_context_files": [...]` to the output JSON).
2.  Modify the Node.js `invokeAiderWrapper` function in `lib/pythonWrapper.js` (from Prompt 7):
    -   Update the function signature to accept `invokeAiderWrapper({ prompt, contextFiles })`. `contextFiles` should be an array of strings.
    -   When spawning the process, iterate through the `contextFiles` array and add a `--context-file` argument to the `spawn` arguments list for each file.
3.  Modify the `@mention` handler (from Prompt 8):
    -   When a repository is found, retrieve its `contextFiles` array from the document.
    -   Pass this array to `invokeAiderWrapper` along with the prompt.
4.  Use standard.js style. Run `standard --fix`.
Testing:
-   Modify `test/pythonWrapper.test.js`: Test calling `invokeAiderWrapper` with an array of `contextFiles`. Assert that the underlying `spawn` call receives the correct `--context-file` arguments. Mock `child_process.spawn` to inspect its arguments.
-   Modify `test/aider_wrapper.test.js`: Test running the Python script directly with multiple `--context-file` arguments. Assert the output JSON includes the `received_context_files` field with the correct paths.
-   Modify `test/mentionHandler.test.js`: Seed the DB repo with context files. Simulate a mention. Mock `invokeAiderWrapper` and assert it's called with the correct `contextFiles` array retrieved from the mock DB.
-   Ensure tests run via `npm test`.
```

**Prompt 13: Encryption Helpers**

```text
Task: Create a Node.js module for AES encryption/decryption.
Requirements:
1.  Create a new file, e.g., `lib/crypto.js`.
2.  Require the built-in `node:crypto` module.
3.  Read a master encryption key from the environment variable `ENCRYPTION_KEY`. Throw an error on startup if it's missing or too short (e.g., less than 32 characters for AES-256).
4.  Export two functions:
    -   `encrypt(text)`:
        -   Generates a random Initialization Vector (IV) (16 bytes for AES).
        -   Creates an AES-256-CBC cipher using the `ENCRYPTION_KEY` and the generated IV.
        -   Encrypts the input `text`.
        -   Returns a string combining the IV and the encrypted text (e.g., `iv.toString('hex') + ':' + encrypted.toString('hex')`).
    -   `decrypt(text)`:
        -   Takes the combined string from `encrypt`.
        -   Splits the string by `:` to get the IV hex and encrypted text hex.
        -   Creates an AES-256-CBC decipher using the `ENCRYPTION_KEY` and the retrieved IV (convert hex back to buffer).
        -   Decrypts the encrypted text.
        -   Returns the original decrypted string.
5.  Handle potential errors during encryption/decryption (e.g., invalid input format for decrypt).
6.  Use standard.js style. Run `standard --fix`.
Testing:
-   Create `test/crypto.test.js` using `tape`.
-   Set a dummy `ENCRYPTION_KEY` environment variable for the test process.
-   Test case 1: Encrypt a sample string. Decrypt the result. Assert the decrypted value matches the original sample.
-   Test case 2: Test `decrypt` with invalid input (e.g., wrong format, incorrect key implicitly). Assert it throws or returns an error/null.
-   Test startup check: Ensure the module throws an error if `ENCRYPTION_KEY` is not set or invalid when required.
-   Ensure tests run via `npm test`.
```

**Prompt 14: Update Repo Schema for SSH Key**

```text
Task: Add the `encryptedSshKey` field to the Repository schema.
Requirements:
1.  Modify `models/Repository.js` (from Prompt 10).
2.  Add a new field to the `repositorySchema`:
    -   `encryptedSshKey`: { type: String } // Not required initially
3.  Use standard.js style. Run `standard --fix`.
Testing:
-   Modify `test/repository.model.test.js` (from Prompt 10).
-   Test creating/updating a repository document with an `encryptedSshKey` value. Assert the value is stored and retrieved correctly.
-   Ensure tests run via `npm test`.
```

**Prompt 15: Extend `/add-repo` for SSH Key**

```text
Task: Modify the `/add-repo` command to accept, encrypt, and store an SSH private key attachment.
Requirements:
1.  Modify the `/add-repo` slash command registration (Prompt 4) to add a required `attachment` option named `ssh_key`.
2.  Modify the `/add-repo` command handler (Prompt 5):
    -   After permission checks, retrieve the `ssh_key` attachment option from the interaction (`interaction.options.getAttachment('ssh_key')`).
    -   Check the attachment's content type (e.g., `text/plain` or common key file types, though validation might be loose initially) and size if needed. Reply with an error if invalid.
    -   Fetch the attachment content using its URL (`attachment.url`). Use `node-fetch` or Node's built-in `fetch` (v18+). Handle fetch errors.
    -   Read the fetched content as text (the private key).
    -   Import the `encrypt` function (Prompt 13). Encrypt the key text.
    -   When saving/updating the `Repository` document, store the encrypted key string in the `encryptedSshKey` field.
    -   Update the confirmation message to indicate the key was received and stored securely.
3.  Add `node-fetch` if Node version < 18.
4.  Use standard.js style. Run `standard --fix`.
Testing:
-   Modify `test/add-repo-command.test.js`.
-   Set a dummy `ENCRYPTION_KEY`.
-   Mock the `interaction` object, including `options.getAttachment` to return a mock attachment object with a URL.
-   Mock `fetch` to return a fake SSH key string when called with the mock URL.
-   Mock the `encrypt` function or use the real one.
-   Assert that the `Repository` model's save/update method is called with the correctly encrypted key data.
-   Test error handling for fetch failures and invalid attachments.
-   Ensure tests run via `npm test`.
```

**Prompt 16: Secure Temp Key Handling**

```text
Task: Create Node.js functions for securely writing and deleting temporary SSH key files. (Deferring ownership/permissions until Docker setup).
Requirements:
1.  Create a new file, e.g., `lib/secureKeys.js`.
2.  Require built-in `node:fs/promises` and `node:path`.
3.  Define a base directory for repositories (e.g., `/repos` or `process.cwd() + '/repos'` for local testing). Read from env var `REPO_BASE_DIR` if available, otherwise use a default.
4.  Export an async function `writeTempKey({ repoName, keyContent })`:
    -   Construct the target directory path: `path.join(baseDir, repoName, '.ssh')`.
    -   Construct the target file path: `path.join(targetDir, 'id_rsa')`.
    -   Ensure the target directory exists using `fs.mkdir(targetDir, { recursive: true })`.
    -   Write the `keyContent` to the target file path using `fs.writeFile`. Set mode `0o600`.
    -   Return the full path to the written key file.
5.  Export an async function `deleteTempKey({ repoName })`:
    -   Construct the target file path as above.
    -   Delete the file using `fs.unlink`. Handle errors if the file doesn't exist (ignore).
    -   Optionally: attempt to remove the `.ssh` directory if empty (`fs.rmdir`), but handle errors gracefully if not empty or non-existent.
6.  Use standard.js style. Run `standard --fix`.
Testing:
-   Create `test/secureKeys.test.js` using `tape`.
-   Use a temporary directory for testing (e.g., using `os.tmpdir()` and a unique subdirectory). Set `REPO_BASE_DIR` env var for the test.
-   Test `writeTempKey`: Call it, assert the file is created in the correct temp location with the correct content and 600 permissions (check `fs.stat`).
-   Test `deleteTempKey`: Call `writeTempKey` then `deleteTempKey`. Assert the file is deleted. Call `deleteTempKey` again, assert no error occurs.
-   Clean up the temporary directory after tests.
-   Ensure tests run via `npm test`.
```

**Prompt 17: Pass SSH Info to Wrapper**

```text
Task: Decrypt the SSH key, write it temporarily, and pass GIT_SSH_COMMAND to the Python wrapper.
Requirements:
1.  Modify `lib/pythonWrapper.js`'s `invokeAiderWrapper` function (from Prompt 12):
    -   Update signature to accept `invokeAiderWrapper({ prompt, contextFiles, repoConfig })`, where `repoConfig` is the full repository document object from the DB.
    -   Import `decrypt` (Prompt 13) and `writeTempKey`, `deleteTempKey` (Prompt 16).
    -   Define `repoName` (e.g., derive from `repoConfig.repoUrl` or add a `repoName` field to the schema later). For now, maybe use `repoConfig._id.toString()`.
    -   If `repoConfig.encryptedSshKey` exists:
        -   Call `decrypt` to get the key content. Handle errors.
        -   Call `writeTempKey` with the `repoName` and decrypted key. Store the returned key file path.
        -   Construct the `GIT_SSH_COMMAND` string: `"ssh -i ${keyFilePath} -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"`.
        -   Add `GIT_SSH_COMMAND` to the `env` option passed to `child_process.spawn`. Make sure to merge with `process.env` so other variables are inherited.
    -   Wrap the `spawn` call and the waiting for it in a `try...finally` block.
    -   In the `finally` block, if a key was written, call `deleteTempKey({ repoName })`. Ensure deletion happens even if `spawn` or the script fails.
2.  Modify the `@mention` handler (Prompt 8):
    -   When a repository document is found, pass the *entire document* (`repoConfig`) to `invokeAiderWrapper`, not just context files.
3.  Use standard.js style. Run `standard --fix`.
Testing:
-   Modify `test/pythonWrapper.test.js`.
-   Set dummy `ENCRYPTION_KEY` and `REPO_BASE_DIR`.
-   Create a mock `repoConfig` object including an `encryptedSshKey` (encrypt a dummy key).
-   Mock `writeTempKey` and `deleteTempKey`.
-   Call `invokeAiderWrapper` with the mock config.
-   Mock `child_process.spawn`. Assert it's called with the correct `env` option containing the `GIT_SSH_COMMAND` pointing to the expected temp key path.
-   Assert `writeTempKey` is called before `spawn`.
-   Assert `deleteTempKey` is called after `spawn` finishes/errors (mock `spawn` to simulate exit/error).
-   Ensure tests run via `npm test`. Clean up temp files/dirs.
```

**Prompt 18: Dockerfile Setup**

```text
Task: Create an initial Dockerfile for the application.
Requirements:
1.  Create a `Dockerfile` in the project root.
2.  Use an official Node.js base image that also includes Python 3 (e.g., `node:XX-slim` might need Python installed, or find a combined image like `node:XX-bullseye`). Choose appropriate versions.
3.  Install necessary OS packages: `git`, `sudo`, `python3`, `python3-pip`, `tree`.
4.  Set up a working directory (e.g., `/app`).
5.  Copy `package.json` and `package-lock.json`.
6.  Run `npm ci --only=production` to install Node.js dependencies.
7.  Create a `requirements.txt` file listing Python dependencies: `aider-chat`.
8.  Copy `requirements.txt`.
9.  Run `pip3 install --no-cache-dir -r requirements.txt`.
10. Copy the rest of the application code (including `aider_wrapper.py`).
11. Expose any necessary port (though the bot doesn't listen directly, maybe relevant later).
12. Define the default command `CMD ["node", "index.js"]`.
Testing:
-   Build the Docker image: `docker build -t discord-aider-bot .`
-   Assert the build completes successfully.
-   (Manual) Run the container with necessary env vars (`DISCORD_TOKEN`, `MONGODB_URI`, `ENCRYPTION_KEY`). Check logs to see if the bot connects to Discord and MongoDB (it won't fully work yet due to missing users/permissions/dirs, but basic startup should function).
```

**Prompt 19: User Creation & `sudo`**

```text
Task: Modify the Dockerfile to create users and configure sudo.
Requirements:
1.  Modify the `Dockerfile` (from Prompt 18):
2.  Before copying application code:
    -   Create a non-root group and user `appuser` (`groupadd -r appuser && useradd -r -g appuser -m -d /app -s /bin/bash appuser`). `/app` will be its home.
    -   Create a group `coders`.
    -   Create a pool of `coderX` users (e.g., `coder1` through `coder5`) belonging to the `coders` group, with home directories under `/repos` (e.g., `/repos/coder1`). Use a loop: `for i in $(seq 1 5); do useradd -r -g coders -m -d /repos/coder$i -s /bin/bash coder$i; done`.
    -   Create the base `/repos` directory and set permissions allowing `appuser` to create subdirs later (`mkdir /repos && chown appuser:appuser /repos && chmod 755 /repos`). Or adjust permissions after creating coder homes.
    -   Install `sudo` if not already done.
    -   Configure passwordless `sudo` for `appuser`. Create a file in `/etc/sudoers.d/` (e.g., `appuser-privs`):
        ```
        # Allow appuser to run specific commands as coderX users
        appuser ALL=(coder1,coder2,coder3,coder4,coder5) NOPASSWD: /usr/bin/python3 /app/aider_wrapper.py *
        appuser ALL=(coder1,coder2,coder3,coder4,coder5) NOPASSWD: /usr/bin/git *
        appuser ALL=(coder1,coder2,coder3,coder4,coder5) NOPASSWD: /bin/rm *
        appuser ALL=(coder1,coder2,coder3,coder4,coder5) NOPASSWD: /bin/mkdir *
        appuser ALL=(coder1,coder2,coder3,coder4,coder5) NOPASSWD: /bin/chown *
        appuser ALL=(coder1,coder2,coder3,coder4,coder5) NOPASSWD: /bin/chmod *
        # Add ls and tree if needed for commands
        appuser ALL=(coder1,coder2,coder3,coder4,coder5) NOPASSWD: /bin/ls *
        appuser ALL=(coder1,coder2,coder3,coder4,coder5) NOPASSWD: /usr/bin/tree *
        ```
        *Ensure paths to executables (`python3`, `git`, etc.) are correct for the base image.* Use `which git`, etc. inside a running container to verify.
    -   Ensure the sudoers file has correct permissions (`chmod 0440 /etc/sudoers.d/appuser-privs`).
3.  After copying code and setting up dependencies:
    -   Change ownership of the `/app` directory to `appuser:appuser` (`chown -R appuser:appuser /app`).
    -   Switch the user: `USER appuser`.
    -   Set the `WORKDIR /app`.
4.  The `CMD` remains the same.
Testing:
-   Rebuild the Docker image: `docker build -t discord-aider-bot .` Assert success.
-   Run the container interactively: `docker run -it --rm --user=appuser discord-aider-bot /bin/bash`.
-   Inside the container (as `appuser`):
    -   Verify `whoami` returns `appuser`.
    -   Verify `sudo -u coder1 whoami` returns `coder1`.
    -   Verify `sudo -u coder1 /usr/bin/git --version` works.
    -   Verify `sudo -u coder1 /bin/rm --version` works.
    -   Verify `sudo -u coder1 touch /tmp/test` fails (as `touch` is not in sudoers).
    -   Verify `/repos` exists and `coderX` home directories exist inside.
```

**Prompt 20: Assign User & Update Schema**

```text
Task: Assign a `coderX` user when adding a repository and store it.
Requirements:
1.  Modify `models/Repository.js` (from Prompt 14):
    -   Add a new field `assignedUserId`: { type: String }. Add an index if needed.
2.  Modify the `/add-repo` command handler (from Prompt 15):
    -   Define the pool of available user IDs (e.g., `['coder1', 'coder2', ..., 'coder5']`). This could be hardcoded or read from config/env.
    -   Before saving the new repository document, query the `repositories` collection to find which `assignedUserId`s are already in use.
    -   Select the first available ID from the pool that is not currently in use. If all are in use, reply with an error ("Maximum repository limit reached.").
    -   Store the selected ID in the `assignedUserId` field of the new repository document.
    -   Update the confirmation message to include the assigned user ID (for debugging/info).
3.  Use standard.js style. Run `standard --fix`.
Testing:
-   Modify `test/add-repo-command.test.js`.
-   Use in-memory MongoDB.
-   Test adding the first repo: Assert `assignedUserId` is 'coder1' (or the first in the pool).
-   Seed the DB with repos assigned to 'coder1', 'coder2'. Test adding another: Assert `assignedUserId` is 'coder3'.
-   Seed the DB with all user IDs assigned. Test adding another: Assert an error reply is sent and no new document is created.
-   Ensure tests run via `npm test`.
```

**Prompt 21: Run Wrapper as Assigned User**

```text
Task: Execute the Python wrapper using `sudo` as the assigned `coderX` user and set the correct working directory. Adjust secure key handling for permissions.
Requirements:
1.  Modify `lib/secureKeys.js` (from Prompt 16):
    -   Update `writeTempKey` signature: `writeTempKey({ repoName, keyContent, ownerUserId })`.
    -   Update `deleteTempKey` signature: `deleteTempKey({ repoName, ownerUserId })`. (Though owner might not be needed for delete if `appuser` can sudo rm).
    -   Inside `writeTempKey`, after writing the file with mode 600:
        -   Use `child_process.execFileSync` or `spawnSync` to run `sudo -u ${ownerUserId} chown ${ownerUserId}:${ownerUserId} ${targetFilePath}`.
        -   Use `child_process.execFileSync` or `spawnSync` to run `sudo -u ${ownerUserId} chmod 600 ${targetFilePath}` (might be redundant but ensures).
        -   Handle errors from these `sudo` commands.
    -   *Alternative:* If `appuser` has sudo rights to write *as* `coderX`, could potentially use `sudo -u ${ownerUserId} dd of=${targetFilePath}` with stdin piping, but `chown/chmod` after writing as `appuser` is likely simpler.
2.  Modify `lib/pythonWrapper.js`'s `invokeAiderWrapper` function (from Prompt 17):
    -   Retrieve `assignedUserId` from the `repoConfig`.
    -   Construct the repository path: `repoPath = path.join(baseDir, repoName)` (`baseDir` from Prompt 16). Ensure this directory will exist (Step 22 handles creation).
    -   When calling `writeTempKey`, pass the `assignedUserId` as `ownerUserId`.
    -   Modify the `spawn` call:
        -   The command is now `sudo`.
        -   Arguments are `['-u', assignedUserId, 'python3', '/app/aider_wrapper.py', '--prompt', prompt, ...]`. Use the absolute path to the wrapper script within the container (`/app/...`).
        -   Set the `cwd` option in `spawn` to `repoPath`.
        -   Keep the `env` option for `GIT_SSH_COMMAND`.
3.  Use standard.js style. Run `standard --fix`.
Testing:
-   Modify `test/secureKeys.test.js`: Update calls to include `ownerUserId`. Mock `child_process` to verify `sudo chown/chmod` commands are called correctly after file writing.
-   Modify `test/pythonWrapper.test.js`:
    -   Provide a mock `repoConfig` including `assignedUserId`.
    -   Assert `writeTempKey` is called with the correct `ownerUserId`.
    -   Mock `child_process.spawn`. Assert it's called with `sudo -u <userId> python3 ...` and the correct `cwd` option set to the expected repo path.
-   These tests might require a Linux environment or careful mocking due to `sudo` and path assumptions.
-   Ensure tests run via `npm test`.
```

**Prompt 22: Basic Git Clone in `/add-repo`**

```text
Task: Clone the repository using Git when `/add-repo` is invoked.
Requirements:
1.  Modify the `/add-repo` command handler (from Prompt 20).
2.  After assigning `assignedUserId` and before saving the `Repository` document (or perhaps after saving, but before replying success):
    -   Import `decrypt` (Prompt 13), `writeTempKey`, `deleteTempKey` (Prompt 21), `path`, `fs/promises`, `child_process`.
    -   Get `baseDir` (Prompt 16). Define `repoName` (e.g., from URL or ID). Construct `repoPath = path.join(baseDir, repoName)`.
    -   Create the repository directory: `await fs.mkdir(repoPath, { recursive: true })`.
    -   Run `sudo -u ${assignedUserId} chown ${assignedUserId}:${assignedUserId} ${repoPath}` using `execFileSync`.
    -   Decrypt the SSH key (`repoConfig.encryptedSshKey`).
    -   Call `writeTempKey({ repoName, keyContent, ownerUserId: assignedUserId })`. Store `keyFilePath`.
    -   Construct `GIT_SSH_COMMAND` env var as in Prompt 17.
    -   Execute the clone command: Use `spawn` or `execFile` for `sudo -u ${assignedUserId} git clone ${repoUrl} .`
        -   Set the `cwd` to `repoPath`.
        -   Pass the `GIT_SSH_COMMAND` in the `env` options (merged with `process.env`).
        -   Capture `stdout` and `stderr`. Wait for completion.
    -   Use a `try...finally` block around the clone operation.
    -   In `finally`, call `deleteTempKey({ repoName, ownerUserId: assignedUserId })`.
    -   If the `git clone` command fails (non-zero exit code or significant stderr), handle the error:
        -   Log the error details (`stderr`).
        -   Clean up: remove the created `repoPath` directory (`fs.rm(repoPath, { recursive: true, force: true })`).
        -   Do *not* save the `Repository` document (if not already saved), or delete it if already saved.
        -   Reply to the user with a specific error: "‚ùå Failed to clone repository. Please check the URL and SSH key permissions. Details logged."
    -   If clone succeeds, proceed to save the `Repository` document (if not already saved) and reply with success.
3.  Use standard.js style. Run `standard --fix`.
Testing:
-   Modify `test/add-repo-command.test.js`. This becomes more of an integration test.
-   Requires mocking `fs`, `child_process`, `decrypt`, `writeTempKey`, `deleteTempKey`.
-   Test success case: Mock `git clone` to exit 0. Assert `Repository.save` is called and success reply sent. Assert temp key is deleted. Assert repo dir and owner are set correctly.
-   Test clone failure case: Mock `git clone` to exit 1 with stderr. Assert `Repository.save` is *not* called (or doc is deleted), error reply is sent, temp key is deleted, repo dir is removed.
-   Use a test Git repository URL (can be fake).
-   Ensure tests run via `npm test`.
```

**Prompt 23: Integrate `aider` in Wrapper**

```text
Task: Modify the Python wrapper to initialize and run the actual `aider` Coder.
Requirements:
1.  Modify `aider_wrapper.py` (from Prompt 12):
2.  Import necessary components from `aider`: `from aider.coders import Coder` and `from aider.io import InputOutput`.
3.  In the main execution block:
    -   Parse arguments (`--prompt`, `--context-file`).
    -   Initialize `io = InputOutput(yes=True)` for non-interactive mode.
    -   Initialize the coder: `coder = Coder(main_model=None, io=io, fnames=context_files)` (replace `context_files` with the parsed list from `--context-file`. Use default model for now). Handle potential initialization errors.
    -   Wrap the execution in a `try...except` block.
    -   Inside `try`: Run the coder: `coder.run(with_message=prompt)` (use `with_message` instead of positional).
    -   Determine success/failure based on whether an exception occurred.
    -   Construct the JSON output object (defined in spec 6.5):
        -   Set `overall_status` to "success" or "failure".
        -   Set `error` to the exception message if failure, else `null`.
        -   Populate `events` array:
            -   Initially, add a single `{"type": "status_message", "content": "Aider run completed."}` on success or `{"type": "status_message", "content": "Aider run failed."}` on failure. More detailed events later.
            -   Consider capturing `coder.io.tool_output` or similar for basic text output and add a `text_response` event if available.
    -   Print the JSON object to stdout.
    -   If an exception occurred, print the stack trace to stderr.
4.  Update `requirements.txt` if specific `aider-chat` version is needed.
Testing:
-   Modify `test/aider_wrapper.test.js`.
-   These tests become harder as they involve the real `aider` library.
-   Option 1 (Mocking `aider`): Use Python's `unittest.mock` within the test setup (e.g., via a helper script called by Node) to mock `aider.coders.Coder` and `coder.run`. Test that `Coder` is initialized with correct args (`fnames`, `io`) and `coder.run` is called with the prompt. Assert the JSON output reflects mock success/failure.
-   Option 2 (Basic Integration): Run the script against a *minimal* test case. Provide a simple prompt and maybe a dummy context file. Assert the script exits cleanly (code 0) and produces valid JSON output (structure check), without necessarily validating `aider`'s specific behavior yet. This requires `aider-chat` to be installed where tests run.
-   Ensure tests run via `npm test`.
```

**Prompt 24: Detect File Changes**

```text
Task: Enhance the Python wrapper to detect file changes made by `aider` and include them in the output.
Requirements:
1.  Modify `aider_wrapper.py` (from Prompt 23):
2.  Requires `gitpython` library: Add `GitPython` to `requirements.txt` and install it (`pip install`).
3.  Import `git`.
4.  Before `coder.run()`:
    -   Initialize `repo = git.Repo('.')` (assuming cwd is the repo root).
    -   Get the set of currently tracked files known to Git: `initial_files = set(item.path for item in repo.index.iter_blobs())`.
    -   Get the initial status/diff to detect modifications to tracked files: `initial_diff = repo.index.diff(None)` (unstaged changes). Store modified paths.
5.  After `coder.run()` completes successfully:
    -   Get the set of tracked files *after* the run: `final_files = set(item.path for item in repo.index.iter_blobs())`. This seems incorrect, need to check untracked/staged files too.
    -   *Alternative Approach:* Use `repo.git.status('--porcelain')` before and after `coder.run`. Parse the output to determine added (`??`), deleted (` D`), modified (` M`), etc. files. This is likely more reliable.
    -   Compare the before/after status.
    -   Iterate through detected changes:
        -   For modified/added files: Read the new content (`open(filepath).read()`). Generate a diff if possible/required by spec (`repo.git.diff('HEAD', filepath)` might work *after* staging, or compare content manually).
        -   For deleted files: Note the filename.
    -   In the JSON output's `events` array:
        -   For each change, add a `file_change` event object:
            ```json
            {
              "type": "file_change",
              "filename": "path/relative/to/repo/root.py",
              "change_type": "modified" | "added" | "deleted",
              "content": "...", // Full new content for added/modified, null for deleted
              "diff": "..."   // Standard diff output for modified, null otherwise
            }
            ```
6.  Refine the `overall_status` based on whether changes occurred. Add status messages.
Testing:
-   Modify `test/aider_wrapper.test.js`. This requires a test environment with a dummy Git repository.
-   Setup: Before running the wrapper script in the test, create a temporary directory, initialize git (`git init`), add and commit a file (`dummy.txt`).
-   Test case 1 (Modification): Run the wrapper script (mocking `coder.run` to simulate modifying `dummy.txt`). Assert the output JSON contains a `file_change` event for `dummy.txt` with `change_type: "modified"`, and includes `content` and/or `diff`.
-   Test case 2 (Addition): Mock `coder.run` to simulate creating a new file `new.txt`. Assert a `file_change` event for `new.txt` with `change_type: "added"` and `content`.
-   Test case 3 (Deletion): Mock `coder.run` to simulate deleting `dummy.txt`. Assert a `file_change` event for `dummy.txt` with `change_type: "deleted"`.
-   Clean up the temporary git directory.
-   Ensure tests run via `npm test`.
```

**Prompt 25: Implement Auto Git Commit/Push**

```text
Task: Add automatic Git staging, commit, and push operations in the Node.js bot after a successful `aider` run with file changes.
Requirements:
1.  Create a new utility function/module for Git operations, e.g., `lib/gitHelper.js`. Export async functions like `gitAddAll`, `gitCommit`, `gitPush`.
    -   These functions take `{ repoPath, assignedUserId, env }` as arguments.
    -   They use `spawn` or `execFile` to execute the corresponding `git` commands (`git add .`, `git commit -m "..."`, `git push origin HEAD:branchName`).
    -   Commands must be run using `sudo -u ${assignedUserId}` with the correct `cwd` and `env` (including `GIT_SSH_COMMAND`).
    -   Handle errors from Git commands (check exit code, stderr).
2.  Modify the main bot logic (e.g., in the `@mention` handler or wherever the wrapper result is processed, likely Prompt 9's location):
3.  After successfully receiving and parsing the wrapper's JSON output (`result.data`):
    -   Check if `result.data.overall_status` is "success".
    -   Check if the `result.data.events` array contains any events with `type: "file_change"`.
    -   If both conditions are true:
        -   Retrieve `repoPath`, `assignedUserId`, `repoUrl`, `channelId` from the `repoConfig`.
        -   Construct the branch name (e.g., `aider/channel-${channelId}`). Ensure it's a valid branch name.
        -   Construct the commit message (e.g., `Aider commit based on user prompt: "${originalPrompt}"`). Keep it concise.
        -   Construct the `env` object with `GIT_SSH_COMMAND`.
        -   Call `gitAddAll({ repoPath, assignedUserId, env })`. Handle errors.
        -   Call `gitCommit({ repoPath, assignedUserId, env, message: commitMessage })`. Handle errors.
        -   Call `gitPush({ repoPath, assignedUserId, env, branchName: branchName })`. Handle errors.
        -   If any Git operation fails, log the error and potentially inform the user ("‚úÖ Changes applied locally, but failed to push to remote."). Do *not* roll back local changes.
        -   If push succeeds, potentially add a confirmation message to the Discord reply ("‚úÖ Changes applied and pushed to branch `${branchName}`.").
4.  Use standard.js style. Run `standard --fix`.
Testing:
-   Create `test/gitHelper.test.js`. Mock `child_process` (`spawn`/`execFile`). Test each helper function (`gitAddAll`, `gitCommit`, `gitPush`) ensures the correct `sudo -u ... git ...` command is executed with proper args, `cwd`, and `env`.
-   Modify `test/mentionHandler.test.js` (or relevant test for processing logic).
-   Mock `invokeAiderWrapper` to return success JSON *with* `file_change` events.
-   Mock the Git helper functions (`gitAddAll`, etc.).
-   Assert that the Git helper functions are called in the correct sequence (add, commit, push) with the right parameters (`repoPath`, `assignedUserId`, commit message, branch name).
-   Test the case where the wrapper returns success but *no* `file_change` events; assert Git functions are *not* called.
-   Test failure handling: mock `gitPush` to throw an error; assert appropriate logging/user message occurs.
-   Ensure tests run via `npm test`.
```

**Prompt 26: Task Queue Schema & Model**

```text
Task: Define MongoDB schema and model for task queues.
Requirements:
1.  Modify `db.js` if necessary (ensure Mongoose connection).
2.  Create a `models/TaskQueue.js` file.
3.  Define a Mongoose schema `taskSchema` for individual tasks within the queue:
    -   `userId`: { type: String, required: true }
    -   `commandType`: { type: String, required: true } // e.g., 'mention', 'add_files'
    -   `commandData`: { type: mongoose.Schema.Types.Mixed } // Store prompt, file paths etc.
    -   `timestamp`: { type: Date, default: Date.now }
4.  Define a Mongoose schema `queueSchema`:
    -   `channelId`: { type: String, required: true, unique: true, index: true }
    -   `queue`: { type: [taskSchema], default: [] }
    -   `isProcessing`: { type: Boolean, default: false } // Flag to prevent concurrent processing
5.  Create and export the Mongoose model: `mongoose.model('TaskQueue', queueSchema)`.
6.  Use standard.js style. Run `standard --fix`.
Testing:
-   Create `test/taskQueue.model.test.js` using `tape`.
-   Use in-memory MongoDB.
-   Test creating a new queue document for a channel.
-   Test adding (`$push`) tasks to the `queue` array.
-   Test finding and updating the `isProcessing` flag.
-   Test retrieving the oldest task and removing it (`$pop` or find+update).
-   Ensure tests run via `npm test`.
```

**Prompt 27: Implement Queue Logic**

```text
Task: Create a queue manager module for enqueuing and processing tasks sequentially per channel.
Requirements:
1.  Create a new file, e.g., `lib/queueManager.js`.
2.  Import the `TaskQueue` model (Prompt 26).
3.  Maintain an in-memory Set or Map `activeChannels` to track channels currently being processed.
4.  Export an async function `enqueueTask(channelId, taskData)`:
    -   `taskData` should match the `taskSchema` structure (userId, commandType, commandData).
    -   Use `TaskQueue.findOneAndUpdate` with `{ channelId: channelId }`, `{ $push: { queue: taskData } }`, and `{ upsert: true, new: true }`.
    -   After enqueuing, call `processQueue(channelId)` (defined below).
5.  Export an async function `processQueue(channelId)`:
    -   Check if `channelId` is already in `activeChannels`. If yes, return (prevent concurrency).
    -   Add `channelId` to `activeChannels`.
    -   Use a `try...finally` block.
    -   Inside `try`:
        -   Use `TaskQueue.findOneAndUpdate({ channelId: channelId, isProcessing: false }, { isProcessing: true })`. If no document is found or modified (meaning it's already processing or empty), return.
        -   Start a loop (`while(true)`).
        -   Find the queue document again: `TaskQueue.findOne({ channelId: channelId })`. If !doc or `doc.queue.length === 0`, break the loop.
        -   Get the next task: `nextTask = doc.queue[0]`.
        -   **Execute the task:** (This is the core logic link)
            -   Based on `nextTask.commandType`, call the appropriate handler (e.g., the logic currently in `@mention` handler from Prompt 9/25, but refactored). Pass `nextTask.commandData`.
            -   This execution part needs to be passed in or configured, e.g., `queueManager.init(taskExecutorFunction)`.
        -   Remove the processed task: `TaskQueue.updateOne({ channelId: channelId }, { $pop: { queue: -1 } })`. Handle errors.
    -   Inside `finally`:
        -   Mark processing as finished: `TaskQueue.updateOne({ channelId: channelId }, { isProcessing: false })`.
        -   Remove `channelId` from `activeChannels`.
6.  The `taskExecutorFunction` passed during initialization should contain the logic to: find repo config, invoke wrapper, handle output, run git commands, reply to user (using data from `nextTask`).
7.  Use standard.js style. Run `standard --fix`.
Testing:
-   Create `test/queueManager.test.js` using `tape`.
-   Use in-memory MongoDB. Mock `TaskQueue` model methods.
-   Mock the `taskExecutorFunction`.
-   Test `enqueueTask`: Assert it calls `findOneAndUpdate` correctly and triggers `processQueue`.
-   Test `processQueue`:
    -   Concurrency: Call `processQueue` twice quickly for the same channel; assert the executor is only called once.
    -   Task Execution: Seed queue with tasks. Call `processQueue`. Assert the executor is called sequentially for each task. Assert tasks are removed. Assert `isProcessing` flag is managed correctly.
    -   Empty Queue: Call `processQueue` on an empty queue; assert executor is not called.
-   Ensure tests run via `npm test`.
```

**Prompt 28: Integrate Queue**

```text
Task: Integrate the queue manager into the bot's command handling.
Requirements:
1.  Refactor the core processing logic (find repo, invoke wrapper, handle output, git ops, reply) from the `@mention` handler (and potentially other command handlers if they become async tasks) into a separate async function, e.g., `executeAiderTask({ channelId, userId, prompt, originalInteractionOrMessage })`. This function will serve as the `taskExecutorFunction` for the queue manager.
2.  In the main bot file (`index.js`):
    -   Import `enqueueTask` and `processQueue` from `lib/queueManager.js`.
    -   Initialize the queue manager, passing the `executeAiderTask` function.
    -   Modify the `@mention` handler (Prompt 8):
        -   Instead of executing directly, create a `taskData` object: `{ userId: message.author.id, commandType: 'mention', commandData: { prompt: extractedPrompt, originalMessageId: message.id } }`.
        -   Call `await enqueueTask(message.channelId, taskData)`.
        -   Reply to the user immediately: "‚è≥ Your request has been added to the queue." (Maybe check queue length first to say "Processing now..." if queue was empty).
    -   Modify other command handlers (`/add`, `/drop`, etc.) IF they need to become queued, long-running tasks (currently they likely don't). `/add-repo` with the clone IS long-running and should probably be queued.
    -   Modify `executeAiderTask` to retrieve the original message/interaction using `originalMessageId` if needed to reply.
3.  Consider triggering `processQueue(channelId)` not just after enqueue, but also periodically or on bot startup for any queues that were left processing (`isProcessing: true`) after a crash.
4.  Use standard.js style. Run `standard --fix`.
Testing:
-   Modify relevant test files (`mentionHandler.test.js`, `addRepoCommand.test.js` if refactored).
-   Mock `enqueueTask`.
-   Test that command handlers (like `@mention`) now call `enqueueTask` with the correct task data instead of executing directly.
-   Test that an immediate queue acknowledgement message is sent.
-   Integration test: Simulate multiple mentions quickly. Verify they are queued and the (mocked) `executeAiderTask` is called sequentially by the queue manager logic (tested in Prompt 27).
-   Ensure tests run via `npm test`.
```

**Prompt 29: Message History Schema & Model**

```text
Task: Define MongoDB schema and model for storing conversation history.
Requirements:
1.  Create a `models/MessageHistory.js` file.
2.  Define a Mongoose schema `messageHistorySchema`:
    -   `channelId`: { type: String, required: true, index: true }
    -   `messageId`: { type: String, required: true, unique: true } // Discord message ID
    -   `authorId`: { type: String, required: true }
    -   `timestamp`: { type: Date, required: true }
    -   `content`: { type: String, required: true }
    -   `type`: { type: String, required: true, enum: ['user_instruction', 'bot_output'] }
3.  Create and export the Mongoose model: `mongoose.model('MessageHistory', messageHistorySchema)`.
4.  Use standard.js style. Run `standard --fix`.
Testing:
-   Create `test/messageHistory.model.test.js` using `tape`.
-   Use in-memory MongoDB.
-   Test creating history documents for both types ('user_instruction', 'bot_output'). Check validation.
-   Test retrieving documents, potentially filtering by `channelId` and sorting by `timestamp`.
-   Ensure tests run via `npm test`.
```

**Prompt 30: Store History**

```text
Task: Store relevant user prompts and bot responses in the message history collection.
Requirements:
1.  Import the `MessageHistory` model (Prompt 29).
2.  In the `@mention` handler (Prompt 28, *before* enqueueing):
    -   After extracting the prompt, create and save a `MessageHistory` document:
        -   `channelId`: `message.channelId`
        -   `messageId`: `message.id`
        -   `authorId`: `message.author.id`
        -   `timestamp`: `message.createdAt`
        -   `content`: The extracted prompt string.
        -   `type`: `'user_instruction'`
    -   Handle potential save errors (e.g., duplicate message ID).
3.  In the `executeAiderTask` function (Prompt 28, *after* processing and getting a reply):
    -   If the task resulted in a successful bot reply (e.g., from a `text_response` event):
        -   Get the content of the reply sent back to Discord.
        -   Get the message ID of the reply message sent by the bot.
        -   Create and save a `MessageHistory` document:
            -   `channelId`: The channel ID from the task.
            -   `messageId`: The bot's reply message ID.
            -   `authorId`: The bot's user ID (`client.user.id`).
            -   `timestamp`: Current time (`new Date()`).
            -   `content`: The bot's reply content.
            -   `type`: `'bot_output'`
        -   Handle potential save errors.
4.  Use standard.js style. Run `standard --fix`.
Testing:
-   Modify `test/mentionHandler.test.js` and tests for `executeAiderTask` (or the queue manager tests).
-   Use in-memory MongoDB.
-   When simulating a mention, assert that a `user_instruction` history document is created with correct data before `enqueueTask` is called.
-   When simulating the execution of a task that produces a reply, mock the Discord reply function to return a mock message object (with an ID). Assert that a `bot_output` history document is created with the correct data.
-   Ensure tests run via `npm test`.
```

**Prompt 31: Retrieve & Pass History**

```text
Task: Retrieve recent conversation history and pass it to the Python wrapper.
Requirements:
1.  Modify `aider_wrapper.py` (from Prompt 24):
    -   Accept a new optional argument, e.g., `--history-json` which expects a JSON string representing the conversation history.
    -   If the argument is provided, parse the JSON. It should be an array of objects like `[{ "role": "user" | "assistant", "content": "..." }]`.
    -   Pass this parsed history to `aider.coders.Coder` during initialization if the library supports it directly, or format it appropriately for the `coder.run(..., history=...)` call if that's the mechanism. Consult `aider-chat` documentation for how it ingests history. (This might need adjustment based on `aider`'s API).
    -   Include the received history length or summary in the output JSON for verification.
2.  Modify the Node.js `executeAiderTask` function (Prompt 28):
    -   Before calling `invokeAiderWrapper`:
        -   Import `MessageHistory` model.
        -   Query the `message_history` collection for the given `channelId`.
        -   Sort by `timestamp` ascending.
        -   Limit the results (e.g., last 20 messages).
        -   Format the retrieved documents into the JSON array structure expected by the Python script (e.g., map `type` 'user_instruction' to role 'user', 'bot_output' to role 'assistant').
        -   Convert the array to a JSON string.
3.  Modify `lib/pythonWrapper.js`'s `invokeAiderWrapper` (Prompt 21):
    -   Update signature: `invokeAiderWrapper({ ..., historyJsonString })`.
    -   If `historyJsonString` is provided, add the `--history-json` argument and its value when spawning the Python script.
4.  Pass the generated `historyJsonString` from `executeAiderTask` to `invokeAiderWrapper`.
5.  Use standard.js style. Run `standard --fix`.
Testing:
-   Modify `test/aider_wrapper.test.js`: Test running the script with the `--history-json` argument containing a sample JSON history string. Assert the output JSON indicates history was received. Mock `aider.coders.Coder` initialization/run to verify it receives the history in the expected format.
-   Modify tests for `executeAiderTask`:
    -   Use in-memory MongoDB. Seed `message_history` with sample messages for a channel.
    -   Mock `invokeAiderWrapper`.
    -   Execute the task for that channel. Assert that `invokeAiderWrapper` is called with a `historyJsonString` argument containing the correctly formatted and ordered JSON representation of the seeded history messages. Test the limit functionality.
-   Ensure tests run via `npm test`.
```

**(Continuing in next response due to length limits)**

---

_**User**_

continue

---

_**Assistant**_



---

Okay, Big D, let's wrap up these prompts.

**Prompt 32: `/ls` & `/tree` Commands**

```text
Task: Implement `/ls` and `/tree` commands to view repository contents.
Requirements:
1.  Register two new slash commands:
    -   `/ls`: Optional string option `directory` (defaults to repo root).
    -   `/tree`: Optional string option `directory` (defaults to repo root).
2.  In the interaction handler:
    -   Handle `ls` and `tree` commands.
    -   Find the repository document for `interaction.channelId`. If none, reply error.
    -   Retrieve `assignedUserId` and `repoName`. Construct `repoPath`.
    -   Get the optional `directory` argument. Perform basic sanitization (prevent escaping the repo dir, e.g., block `..`, absolute paths). If invalid, reply error. Default to `.` if not provided.
    -   Construct the target path within the repo: `path.join(repoPath, sanitizedDirectory)`. Ensure it's still within `repoPath`.
    -   Use `child_process.spawn` or `execFile` to run the command (`ls -la` or `tree -L 2` - limit depth initially) via `sudo`:
        -   Command: `sudo`
        -   Args: `['-u', assignedUserId, commandName, options..., targetPath]` (e.g., `sudo -u coder1 ls -la /repos/repo1/subdir`)
        -   Set `cwd` to `repoPath` (or maybe `/`).
        -   Capture `stdout` and `stderr`.
    -   If the command fails (non-zero exit, stderr), reply with an error message (e.g., "Directory not found or error listing files.").
    -   If successful, format the `stdout` content (trimming, maybe using code blocks) and send it as a reply. Handle potentially large output (split messages or use file attachment if >2000 chars).
3.  Ensure `ls` and `tree` are installed in the Docker image (Prompt 19) and the `sudoers` file allows `appuser` to run them as `coderX`.
4.  Use standard.js style. Run `standard --fix`.
Testing:
-   Create `test/filesystemCommands.test.js` using `tape`.
-   Mock `child_process` (`spawn`/`execFile`).
-   Mock finding the `Repository` document.
-   Test `/ls` (no args): Assert `sudo -u <user> ls ... <repoPath>` is called. Mock stdout and assert reply contains it.
-   Test `/ls` (with valid subdir): Assert `sudo -u <user> ls ... <repoPath>/subdir` is called.
-   Test `/ls` (with invalid dir like `../`): Assert command is *not* run and an error reply is sent.
-   Test `/tree`: Similar tests for the `tree` command.
-   Test command failure: Mock `spawn` to return error/stderr. Assert error reply is sent.
-   Test large output handling (if implemented).
-   Ensure tests run via `npm test`.
```

**Prompt 33: `/diff` Command**

```text
Task: Implement the `/diff` command to show the last bot commit's changes.
Requirements:
1.  Register a new slash command `/diff` (no options needed initially).
2.  In the interaction handler:
    -   Handle the `diff` command.
    -   Find the repository document for `interaction.channelId`. If none, reply error.
    -   Retrieve `assignedUserId`, `repoName`, `channelId`. Construct `repoPath`.
    -   Determine the branch name used for pushes (e.g., `branchName = \`aider/channel-${channelId}\``).
    -   Use `child_process.spawn` or `execFile` to run `sudo -u ${assignedUserId} git diff HEAD~1..HEAD`:
        -   Command: `sudo`
        -   Args: `['-u', assignedUserId, 'git', 'diff', 'HEAD~1..HEAD']` (Note: Assumes the last commit *is* the relevant one. May need adjustment if other commits happen on the branch). Alternatively, `git show HEAD`.
        -   Set `cwd` to `repoPath`.
        -   Set `env` including `GIT_SSH_COMMAND` (though likely not needed for `diff`).
        -   Capture `stdout` and `stderr`.
    -   If the command fails (e.g., no previous commit), reply with an error ("No previous commit found or error generating diff.").
    -   If successful:
        -   Get the `stdout` (the diff content).
        -   If the diff is empty, reply "No changes found in the last commit."
        -   If diff has content, send it as a file attachment:
            -   Create a Discord `AttachmentBuilder` with the diff content.
            -   Set the filename to `last_commit.diff`.
            -   Reply with the attachment.
3.  Use standard.js style. Run `standard --fix`.
Testing:
-   Create `test/diffCommand.test.js` using `tape`.
-   Mock `child_process`.
-   Mock finding the `Repository` document.
-   Test successful diff: Mock `git diff` to return diff content in stdout. Assert `interaction.reply` is called with a file attachment named `last_commit.diff` containing the stdout content.
-   Test empty diff: Mock `git diff` stdout to be empty. Assert reply indicates no changes.
-   Test Git error: Mock `git diff` to fail. Assert error reply is sent.
-   Ensure tests run via `npm test`.
```

**Prompt 34: `/clear` Command**

```text
Task: Implement the `/clear` command to reset context and history.
Requirements:
1.  Register a new slash command `/clear` (no options).
2.  In the interaction handler:
    -   Handle the `clear` command.
    -   Find the repository document for `interaction.channelId`. If none, reply error.
    -   Import `MessageHistory` model (Prompt 29). Delete all history documents matching the `channelId`: `MessageHistory.deleteMany({ channelId: interaction.channelId })`. Handle errors.
    -   Update the repository document: Set `contextFiles` to an empty array (`[]`). Use `Repository.updateOne({ discordChannelId: interaction.channelId }, { $set: { contextFiles: [] } })`. Handle errors.
    -   (Future consideration: Could potentially call `aider` via wrapper with a 'clear state' command if available).
    -   Reply to the user confirming that context and conversation history have been cleared for the channel.
3.  Use standard.js style. Run `standard --fix`.
Testing:
-   Create `test/clearCommand.test.js` using `tape`.
-   Use in-memory MongoDB.
-   Seed `repositories` with a doc having `contextFiles`. Seed `message_history` with docs for that channel.
-   Mock the `interaction` object.
-   Execute the `/clear` command handler.
-   Assert `MessageHistory.deleteMany` is called for the correct channel.
-   Assert `Repository.updateOne` is called to set `contextFiles` to `[]`.
-   Assert the confirmation reply is sent.
-   Verify the DB state after the command (history deleted, context files empty).
-   Ensure tests run via `npm test`.
```

**Prompt 35: Refine Error Handling & Logging**

```text
Task: Improve error handling and logging throughout the application.
Requirements:
1.  Review all modules (`index.js`, command handlers, wrapper invoker, Git helpers, queue manager, DB interactions, Python script).
2.  Implement centralized logging: Use a library like `pino` or `winston`. Configure it for appropriate log levels (info, warn, error) and structured logging (JSON). Log to stdout/stderr for Docker compatibility.
3.  Replace `console.log/error` with logger calls.
4.  Error Handling Strategy:
    -   Catch specific errors where possible (DB errors, Git errors, Python script errors, Discord API errors, FS errors).
    -   Distinguish between:
        -   User Errors (e.g., invalid input, repo not found, permissions): Report clearly to user via Discord reply. Log at info/warn level.
        -   Internal/Unexpected Errors (e.g., DB connection lost, script crash, unhandled exception): Report generic error to user ("An internal error occurred..."). Log detailed error with stack trace at error level.
    -   Ensure `try...catch` and `try...finally` blocks are used appropriately, especially around I/O, process spawning, and DB operations.
    -   In `aider_wrapper.py`, ensure exceptions are caught, logged to stderr (stack trace), and a proper failure JSON is sent to stdout.
5.  Sensitive Data: Review logs to ensure sensitive data (decrypted SSH keys, full file paths if sensitive, raw DB errors that might leak info) is *not* logged directly. Log placeholders or summaries instead. `ENCRYPTION_KEY` should never be logged.
6.  Python Script `stderr`: Ensure `stderr` from `aider_wrapper.py` is captured by the Node.js invoker and logged internally (at error level if script failed, maybe debug level otherwise) but *never* shown directly to the user.
7.  Use standard.js style. Run `standard --fix`.
Testing:
-   This involves reviewing and refactoring existing code rather than adding distinct features.
-   Enhance existing tests:
    -   Check that appropriate log messages (mocking the logger) are generated for success and failure cases.
    -   Verify stack traces are logged for internal errors.
    -   Verify user-facing error replies are clear and don't leak internal details.
    -   Verify sensitive data isn't present in mock log output.
-   Manual testing: Trigger various error conditions (invalid repo URL, bad SSH key, invalid directory for `/ls`, mention in unconfigured channel) and check bot replies and container logs (`docker logs`).
-   Ensure tests run via `npm test`.
```

**Prompt 36: Autocomplete**

```text
Task: Implement slash command autocomplete for file/directory paths.
Requirements:
1.  Modify command registration for `/add`, `/drop`, `/ls`, `/tree` to enable autocomplete for the relevant options (`paths`, `directory`). Set `autocomplete: true` in the option definition.
2.  Add a handler for the `InteractionType.ApplicationCommandAutocomplete` event in `index.js`.
3.  Inside the autocomplete handler:
    -   Get the focused option name and value (`interaction.options.getFocused(true)`).
    -   Get the `commandName` and `channelId`.
    -   Find the repository document for the `channelId`. If none, respond with an empty array `interaction.respond([])`.
    -   Retrieve `assignedUserId`, `repoName`. Construct `repoPath`.
    -   Determine the base directory for suggestions:
        -   For `/ls`, `/tree`: Use the current value of the `directory` option being typed. Default to repo root if empty.
        -   For `/add`, `/drop`: Depends on desired behavior. Could suggest files/dirs from root, or from the directory part of the currently typed path in the `paths` option. Start simple: suggest from root.
    -   Construct the target path for listing (`path.join(repoPath, baseDirForSuggestions)`). Sanitize input.
    -   Use `child_process.spawn` (`sudo -u ... ls -p`) inside the target path. `-p` adds `/` to directories. Capture stdout. Handle errors gracefully (respond empty).
    -   Parse the `ls` output (stdout lines). Filter out unwanted entries (like `.`, `..`, maybe hidden files).
    -   Filter the results based on the currently focused value (`focusedOption.value`). Keep entries that *start with* the typed value.
    -   Limit the number of suggestions (e.g., Discord limit is 25).
    -   Format the suggestions as an array of `{ name: string, value: string }` objects. `name` is what the user sees, `value` is what's sent when selected.
    -   Call `interaction.respond()` with the array of suggestions.
4.  Handle permissions and sanitization carefully when constructing paths for `ls`.
5.  Make autocomplete responsive; avoid long-running operations. `ls` should be fast enough.
6.  Use standard.js style. Run `standard --fix`.
Testing:
-   Create `test/autocomplete.test.js` using `tape`.
-   Mock the `interaction` object (type Autocomplete). Set `commandName`, `channelId`, focused option/value.
-   Mock finding the `Repository` document.
-   Mock `child_process.spawn` for the `ls` call. Provide sample `ls -p` stdout.
-   Test case 1 (Root suggestions): Focused option empty. Assert `ls` is called for repo root. Assert `interaction.respond` is called with formatted suggestions based on mock stdout.
-   Test case 2 (Filtering): Focused option value is "src". Assert `interaction.respond` suggestions are filtered (e.g., only "src/", "src/file.js").
-   Test case 3 (Subdir suggestions for `/ls`): Focused option is `directory`, value is "src/". Assert `ls` is called for the subdirectory.
-   Test case 4 (No repo): Assert `interaction.respond([])` is called.
-   Test `ls` error handling.
-   Ensure tests run via `npm test`.
```

**Prompt 37: `/undo` Command**

```text
Task: Implement an `/undo` command to revert the last commit made by the bot.
Requirements:
1.  Register a new slash command `/undo` (no options).
2.  In the interaction handler:
    -   Handle the `undo` command.
    -   Find the repository document for `interaction.channelId`. If none, reply error.
    -   Retrieve `assignedUserId`, `repoPath`, `channelId`. Construct `branchName`.
    -   This command needs queueing like other repo operations. Refactor to use the queue manager:
        -   Enqueue a task: `{ userId: interaction.user.id, commandType: 'undo', commandData: { originalInteractionId: interaction.id } }`. Reply "Undo request queued".
    -   Create a new handler function `executeUndoTask({ channelId, userId, commandData })` to be called by the queue manager.
    -   Inside `executeUndoTask`:
        -   Retrieve repo config (`assignedUserId`, `repoPath`, `branchName`).
        -   Construct `env` with `GIT_SSH_COMMAND`.
        -   Execute `sudo -u ${assignedUserId} git revert HEAD --no-edit` using spawn/execFile in `repoPath` with `env`. Capture output/errors.
            -   If revert fails (e.g., merge conflicts, no commit to revert), report error to user via reply (fetch original interaction by ID). Log details.
        -   If revert succeeds:
            -   Execute `sudo -u ${assignedUserId} git push origin HEAD:${branchName}` using spawn/execFile in `repoPath` with `env`. Capture output/errors.
            -   If push fails, report success of local revert but failure to push. Log details.
            -   If push succeeds, report successful undo and push.
        -   Reply to the original interaction indicating success or failure.
3.  Add 'undo' to `commandType` enum/checks in queue manager.
4.  Use standard.js style. Run `standard --fix`.
Testing:
-   Modify `test/queueManager.test.js` or create `test/undoCommand.test.js`.
-   Test the interaction handler part: Assert it calls `enqueueTask` with correct `commandType: 'undo'`.
-   Test `executeUndoTask`:
    -   Mock `child_process`.
    -   Mock finding repo config.
    -   Mock Discord `reply`/`editReply`.
    -   Test success: Mock `git revert` and `git push` to succeed. Assert success reply is sent.
    -   Test revert failure: Mock `git revert` to fail. Assert error reply is sent, `git push` is not called.
    -   Test push failure: Mock `git revert` success, `git push` failure. Assert reply indicates partial success.
-   Ensure tests run via `npm test`.
```

There you have it, Big D. A full set of iterative, test-driven prompts based on the blueprint derived from `spec.md`. Let the coding commence!

---

_**User**_

create directory docs/prompts

---

_**Assistant**_



---

Okay Big D, I can create that directory for you.



---

```bash
mkdir -p docs/prompts
```

```


~/play/test/vibehive main

```

---

Done. The directory `docs/prompts` has been created.

---

_**User**_

create prompts/01.md

---

_**Assistant**_



---

Okay, Big D, I will create the file `docs/prompts/01.md`. I'll assume you meant inside the `docs/prompts` directory we just created.



---

```diff
- 
+  
```

---

File `docs/prompts/01.md` created.

---

_**User**_

put the contents of prompt 1 in it

---

_**Assistant**_



---

Okay, Big D. I will put the content of the first prompt into `docs/prompts/01.md`.



---

```diff
-  
+ ```text
+ Task: Create a basic Node.js Discord bot using discord.js v14.
+ Requirements:
+ 1.  Initialize a new Node.js project (`npm init -y`, add `discord.js`).
+ 2.  Create an entry point file (`index.js` or `bot.js`).
+ 3.  Use environment variables for the Discord Bot Token (`DISCORD_TOKEN`). Use `dotenv` package.
+ 4.  Implement basic login logic to connect the bot to Discord.
+ 5.  Register a simple slash command `/ping`.
+ 6.  Implement an interaction handler that replies "Pong!" to the `/ping` command.
+ 7.  Include a basic `README.md` explaining setup (install deps, create `.env` with token, run `node .`).
+ 8.  Use standard.js style. Add `standard` as a dev dependency and include a lint script in `package.json`. Run `standard --fix`.
+ 9.  Add basic logging for 'ready' and 'interactionCreate' events.
+ Testing:
+ -   Create a `test/ping.test.js` using `tape`.
+ -   The test should ideally mock the Discord client or parts of it to verify command registration and response logic without actually connecting to Discord. Focus on testing the handler logic.
+ -   Ensure tests run via `npm test` and exit cleanly.
+ ``` 
```

---

Alright, Big D, the content of Prompt 1 has been written to `docs/prompts/01.md`.

---

_**User**_

do the same for 2 and 3

---

_**Assistant**_



---

Okay, Big D, I'll create `docs/prompts/02.md` and `docs/prompts/03.md` and put the corresponding prompt content into them.

First, creating `docs/prompts/02.md` with Prompt 2 content.


---

```diff
- 
+ Task: Integrate MongoDB connection logic into the bot from Prompt 1.
+ Requirements:
+ 1.  Add the `mongodb` npm package.
+ 2.  Create a configuration file/module (`config.js`) that reads `MONGODB_URI` and `MONGODB_DB_NAME` from environment variables (`.env`).
+ 3.  Create a database connection module (`db.js` or `lib/mongo.js`).
+     -   It should export an async function `connectDB` that connects to MongoDB using the URI from config.
+     -   It should handle connection errors gracefully (log and potentially exit).
+     -   It should store the connected client or db instance for reuse.
+     -   It should export a function `getDB` to retrieve the db instance.
+ 4.  Call `connectDB` in the main bot file (`index.js`) after login, before starting command handling. Ensure the bot waits for the connection before proceeding.
+ 5.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Create `test/db.test.js` using `tape`.
+ -   Use `mongodb-memory-server` (add as dev dependency) to spin up an in-memory MongoDB for testing.
+ -   Test that `connectDB` successfully connects to the in-memory server.
+ -   Test that `getDB` returns a valid DB instance after connection.
+ -   Ensure tests run via `npm test` and exit cleanly. 
```

---

Now, creating `docs/prompts/03.md` with Prompt 3 content.


---

```diff
- 
+ Task: Define a MongoDB schema and model for repositories.
+ Requirements:
+ 1.  Add the `mongoose` npm package (although `mongodb` driver is already added, Mongoose simplifies schema definition and validation, let's use it for models).
+ 2.  Modify `db.js` (from Prompt 2) to use `mongoose.connect` instead of the raw driver connection, or adapt it to work alongside the driver if preferred (keep it simple, maybe replace raw driver usage). Ensure `getDB` still works or adapt dependent code.
+ 3.  Create a `models/Repository.js` file.
+ 4.  Define a Mongoose schema `repositorySchema` with the following fields initially:
+     -   `repoUrl`: { type: String, required: true }
+     -   `discordChannelId`: { type: String, required: true, unique: true } // Assuming one repo per channel
+ 5.  Create and export the Mongoose model: `mongoose.model('Repository', repositorySchema)`.
+ 6.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Create `test/repository.model.test.js` using `tape`.
+ -   Connect to the in-memory MongoDB server.
+ -   Test creating a new repository document using the model. Check for validation errors (e.g., missing `repoUrl`).
+ -   Test retrieving a saved document.
+ -   Ensure tests run via `npm test` and exit cleanly, disconnecting Mongoose properly (`mongoose.connection.close()`). 
```

---

Done. Files `docs/prompts/02.md` and `docs/prompts/03.md` have been created with their respective prompt content, Big D.

---

_**User**_

do the same for 4 through 10

---

_**Assistant**_



---

Okay Big D, let's create the files for prompts 4 through 10.

Creating `docs/prompts/04.md` with Prompt 4 content.


---

```diff
- 
+ Task: Implement a stub for the `/add-repo` slash command.
+ Requirements:
+ 1.  Modify the bot's command registration logic (likely from Prompt 1) to register a new slash command `/add-repo`.
+ 2.  The command should have one required string option: `url`.
+ 3.  Modify the interaction handler:
+     -   Check if the interaction `commandName` is `add-repo`.
+     -   Check if the user invoking the command has Administrator permissions (`interaction.member.permissions.has(PermissionsBitField.Flags.Administrator)`). If not, reply with an error message and return.
+     -   If admin, retrieve the value of the `url` option.
+     -   Reply with a temporary acknowledgement message like "Received request to add repo: [URL]".
+ 4.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Create `test/add-repo-command.test.js` using `tape`.
+ -   Mock the `interaction` object.
+ -   Test that non-admins receive a permission error reply.
+ -   Test that admins receive the acknowledgement reply, including the passed URL.
+ -   Verify the handler correctly identifies the command and extracts the option.
+ -   Ensure tests run via `npm test`. 
```

---

Creating `docs/prompts/05.md` with Prompt 5 content.


---

```diff
- 
+ Task: Enhance the `/add-repo` command to store repository information in MongoDB.
+ Requirements:
+ 1.  Modify the `/add-repo` command handler (from Prompt 4).
+ 2.  After checking admin permissions and retrieving the `url`:
+     -   Get the `channelId` from the `interaction` object (`interaction.channelId`).
+     -   Import the `Repository` model (from Prompt 3). Query the database to find a repository document matching the `channelId`.
+     -   Use the model to create or update (upsert might be suitable, or find-and-update) a document in the `repositories` collection. Store the `repoUrl` and `discordChannelId`. Handle potential database errors (e.g., duplicate channel ID if not using upsert).
+     -   Reply to the user confirming the repository configuration has been saved (e.g., "Repository configuration for [URL] saved for this channel."). Include error reporting if the save fails.
+ 3.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Modify `test/add-repo-command.test.js` or create a new test file.
+ -   Use the in-memory MongoDB server.
+ -   Mock the `interaction` object with admin permissions, a channel ID, and a URL.
+ -   After simulating the command execution, assert that a corresponding document exists in the database with the correct `repoUrl` and `discordChannelId`.
+ -   Test error handling for database failures (e.g., mock the model's save/update method to throw an error).
+ -   Ensure tests run via `npm test` and the database is clean after tests. 
```

---

Creating `docs/prompts/06.md` with Prompt 6 content.


---

```diff
- 
+ Task: Create a basic Python script (`aider_wrapper.py`) that acts as a placeholder for the real `aider` interaction.
+ Requirements:
+ 1.  Create the file `aider_wrapper.py` in the project root or a suitable subdirectory (e.g., `scripts/`).
+ 2.  Use Python's `argparse` module to accept one command-line argument: `--prompt`.
+ 3.  Use Python's `json` module.
+ 4.  The script should parse the arguments.
+ 5.  The script should print a JSON object to standard output with the following structure:
+     ```json
+     {
+       "overall_status": "success",
+       "error": null,
+       "events": [
+         {
+           "type": "text_response",
+           "content": "Placeholder response for prompt: [PROMPT_VALUE]"
+         }
+       ]
+     }
+     ```
+     Replace `[PROMPT_VALUE]` with the actual value received from the `--prompt` argument.
+ 6.  If the `--prompt` argument is missing, it should print an error message to stderr and exit with a non-zero status code.
+ 7.  Ensure the script is executable (`chmod +x aider_wrapper.py`).
+ Testing:
+ -   Create `test/aider_wrapper.test.js` (Node.js test file using `tape` and `child_process`).
+ -   Test running the Python script as a child process from Node.js.
+ -   Test case 1: Provide `--prompt "hello"`. Assert that the child process exits with code 0 and stdout contains the expected JSON structure with the correct placeholder text.
+ -   Test case 2: Run without `--prompt`. Assert that the child process exits with a non-zero code and stderr contains an error message.
+ -   Ensure tests run via `npm test`. 
```

---



---

Creating `docs/prompts/07.md` with Prompt 7 content.


---

```diff
- 
+ Task: Create a Node.js module to spawn and manage the `aider_wrapper.py` script.
+ Requirements:
+ 1.  Create a new file, e.g., `lib/pythonWrapper.js`.
+ 2.  This module should export an async function, e.g., `invokeAiderWrapper({ prompt })`.
+ 3.  Inside this function:
+     -   Use `child_process.spawn` to execute the `aider_wrapper.py` script (using `python3`).
+     -   Pass the `prompt` value using the `--prompt` argument.
+     -   Capture `stdout` and `stderr` streams.
+     -   Wait for the process to exit.
+     -   If the exit code is non-zero or `stderr` is not empty, return an error object (e.g., `{ status: 'failure', error: stderrContent, stdout: stdoutContent }`).
+     -   If the exit code is 0, parse the `stdout` content as JSON.
+     -   If JSON parsing fails, return an error object.
+     -   If JSON parsing succeeds, return the parsed object (e.g., `{ status: 'success', data: parsedJson }`).
+ 4.  Handle potential errors during process spawning itself (e.g., script not found).
+ 5.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Create `test/pythonWrapper.test.js` using `tape`.
+ -   Test the `invokeAiderWrapper` function.
+ -   Test case 1 (Success): Call with a prompt. Assert that the function returns the expected success object containing the parsed JSON from the stub script (Prompt 6).
+ -   Test case 2 (Script Error): Modify the test to make the script exit non-zero (e.g., by not passing `--prompt`). Assert that the function returns a failure object with the captured stderr.
+ -   Test case 3 (Spawn Error): Mock `child_process.spawn` to throw an error. Assert the function handles it gracefully.
+ -   Test case 4 (JSON Parse Error): Modify the test script to output invalid JSON. Assert the function returns a failure object indicating a parse error.
+ -   Ensure tests run via `npm test`. 
```

---



---

Creating `docs/prompts/08.md` with Prompt 8 content.


---

```diff
- 
+ Task: Implement logic to handle bot mentions and trigger the Python wrapper.
+ Requirements:
+ 1.  In the main bot file (`index.js`), add a handler for the `messageCreate` event from `discord.js`.
+ 2.  Inside the handler:
+     -   Ignore messages from bots (including itself).
+     -   Check if the bot was mentioned in the message content (`message.mentions.has(client.user)`).
+     -   If mentioned, extract the message content, removing the mention itself to get the user's prompt string. Trim whitespace.
+     -   Get the `channelId` from the message (`message.channelId`).
+     -   Import the `Repository` model (Prompt 3). Query the database to find a repository document matching the `channelId`.
+     -   If no repository is found for the channel, reply politely indicating the channel isn't configured and return.
+     -   If a repository is found:
+         -   Import and call the `invokeAiderWrapper` function (Prompt 7) with the extracted prompt.
+         -   (For now, just log the result or error. Output display will be in the next step).
+ 3.  Ensure the bot has the necessary Intents enabled (e.g., `GatewayIntentBits.Guilds`, `GatewayIntentBits.GuildMessages`, `GatewayIntentBits.MessageContent`). Update the client initialization if needed. Remember `MessageContent` is privileged.
+ 4.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Create `test/mentionHandler.test.js` using `tape`.
+ -   Use the in-memory MongoDB. Seed it with a test repository document.
+ -   Mock the `message` object and `client.user`.
+ -   Test case 1 (No Mention): Simulate a message without mentioning the bot. Assert the wrapper is *not* called.
+ -   Test case 2 (Mention, No Repo): Simulate a mention in a channel *not* in the DB. Assert the wrapper is *not* called and a specific reply is sent.
+ -   Test case 3 (Mention, Repo Found): Simulate a mention in a channel *with* a configured repo. Assert that `invokeAiderWrapper` is called with the correctly extracted prompt. Mock `invokeAiderWrapper` to verify it's called.
+ -   Ensure tests run via `npm test`. 
```

---



---

Creating `docs/prompts/09.md` with Prompt 9 content.


---

```diff
- 
+ Task: Parse the output from the Python wrapper and display the response in Discord.
+ Requirements:
+ 1.  Modify the `messageCreate` handler (from Prompt 8).
+ 2.  After receiving the result from `invokeAiderWrapper`:
+     -   Check the `status` field of the result.
+     -   If `status` is 'failure', reply to the original message with a generic error (e.g., "‚ùå An error occurred while processing your request. Details logged."). Log the detailed error (`result.error`, `result.stdout`) internally.
+     -   If `status` is 'success':
+         -   Access the parsed JSON data (`result.data`).
+         -   Check `result.data.overall_status`. If it's 'failure', report an error similar to the above, logging `result.data.error`.
+         -   If `result.data.overall_status` is 'success':
+             -   Find the first event with `type: "text_response"` in the `result.data.events` array.
+             -   If found, reply to the original message with the `content` of that event.
+             -   If no `text_response` event is found, reply with a message indicating success but no text output.
+ 3.  Handle potential network errors when replying to Discord.
+ 4.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Modify `test/mentionHandler.test.js`.
+ -   Mock `invokeAiderWrapper` to return different results:
+     -   Success case: Return the standard placeholder JSON. Assert that `message.reply` is called with the correct placeholder text.
+     -   Wrapper failure case: Return `{ status: 'failure', error: 'stderr output' }`. Assert `message.reply` is called with a generic error message.
+     -   Script failure case: Return `{ status: 'success', data: { overall_status: 'failure', error: 'script error', events: [] } }`. Assert `message.reply` is called with a generic error message.
+     -   No text response case: Return `{ status: 'success', data: { overall_status: 'success', events: [] } }`. Assert `message.reply` is called with an appropriate message.
+ -   Mock `message.reply` to verify its arguments and prevent actual Discord calls.
+ -   Ensure tests run via `npm test`. 
```

---



---

Creating `docs/prompts/10.md` with Prompt 10 content.


---

```diff
- 
+ Task: Add the `contextFiles` field to the Repository schema.
+ Requirements:
+ 1.  Modify `models/Repository.js` (from Prompt 3).
+ 2.  Add a new field to the `repositorySchema`:
+     -   `contextFiles`: { type: [String], default: [] }
+ 3.  Ensure existing model usage is not broken (Mongoose should handle the default).
+ 4.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Modify `test/repository.model.test.js` (from Prompt 3).
+ -   Test creating a new repository document. Assert that `contextFiles` exists and is an empty array by default.
+ -   Test updating an existing document to add file paths to `contextFiles`. Assert the update is successful.
+ -   Ensure tests run via `npm test`. 
```

---

All done, Big D. Files `docs/prompts/04.md` through `docs/prompts/10.md` have been created with their corresponding prompt content.

---

_**User**_

do this for  11-20

---

_**Assistant**_



---

Okay Big D, grinding through prompts 11 to 20 now.

Creating `docs/prompts/11.md` with Prompt 11 content.


---

```diff
- 
+ Task: Implement slash commands for managing context files.
+ Requirements:
+ 1.  Register three new slash commands:
+     -   `/files`: No options.
+     -   `/add`: One required string option `paths` (Description: Space-separated file paths).
+     -   `/drop`: One required string option `paths` (Description: Space-separated file paths).
+ 2.  In the interaction handler:
+     -   Handle `files` command:
+         -   Find the repository document for the `interaction.channelId`. If none, reply error.
+         -   Retrieve the `contextFiles` array.
+         -   Reply with the list of files, nicely formatted (e.g., in a code block or numbered list), or "No files currently in context."
+     -   Handle `add` command:
+         -   Find the repository document for the `interaction.channelId`. If none, reply error.
+         -   Get the `paths` string option. Split it by spaces to get an array of potential file paths. Filter out empty strings.
+         -   Perform basic validation (e.g., reject paths starting with `/` or containing `..`). Reply with error for invalid paths.
+         -   Update the repository document by adding the valid new paths to the `contextFiles` array (avoid duplicates). Use MongoDB's `$addToSet` with `$each`.
+         -   Reply confirming which files were added.
+     -   Handle `drop` command:
+         -   Find the repository document for the `interaction.channelId`. If none, reply error.
+         -   Get the `paths` string option. Split it by spaces.
+         -   Update the repository document by removing the specified paths from the `contextFiles` array. Use MongoDB's `$pull` with `$in`.
+         -   Reply confirming which files were removed (or indicate if they weren't found).
+ 3.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Create `test/contextCommands.test.js` using `tape`.
+ -   Use in-memory MongoDB. Seed with a test repository.
+ -   Mock the `interaction` object for each command.
+ -   Test `/files`: Assert the reply contains the expected files from the seeded document.
+ -   Test `/add`: Assert the DB document is updated correctly (files added, duplicates ignored). Test validation rejects bad paths. Verify reply message.
+ -   Test `/drop`: Assert the DB document is updated correctly (files removed). Verify reply message.
+ -   Test commands fail gracefully if no repo is configured for the channel.
+ -   Mock `interaction.reply`.
+ -   Ensure tests run via `npm test`. 
```

---

Creating `docs/prompts/12.md` with Prompt 12 content.


---

```diff
- 
+ Task: Pass the stored context files to the Python wrapper script.
+ Requirements:
+ 1.  Modify `aider_wrapper.py` (from Prompt 6):
+     -   Use `argparse` to accept multiple occurrences of a `--context-file` argument (`action='append'`).
+     -   Include the received context file paths in the JSON output for verification (e.g., add a field like `"received_context_files": [...]` to the output JSON).
+ 2.  Modify the Node.js `invokeAiderWrapper` function in `lib/pythonWrapper.js` (from Prompt 7):
+     -   Update the function signature to accept `invokeAiderWrapper({ prompt, contextFiles })`. `contextFiles` should be an array of strings.
+     -   When spawning the process, iterate through the `contextFiles` array and add a `--context-file` argument to the `spawn` arguments list for each file.
+ 3.  Modify the `@mention` handler (from Prompt 8):
+     -   When a repository is found, retrieve its `contextFiles` array from the document.
+     -   Pass this array to `invokeAiderWrapper` along with the prompt.
+ 4.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Modify `test/pythonWrapper.test.js`: Test calling `invokeAiderWrapper` with an array of `contextFiles`. Assert that the underlying `spawn` call receives the correct `--context-file` arguments. Mock `child_process.spawn` to inspect its arguments.
+ -   Modify `test/aider_wrapper.test.js`: Test running the Python script directly with multiple `--context-file` arguments. Assert the output JSON includes the `received_context_files` field with the correct paths.
+ -   Modify `test/mentionHandler.test.js`: Seed the DB repo with context files. Simulate a mention. Mock `invokeAiderWrapper` and assert it's called with the correct `contextFiles` array retrieved from the mock DB.
+ -   Ensure tests run via `npm test`. 
```

---

Creating `docs/prompts/13.md` with Prompt 13 content.


---

```diff
- 
+ Task: Create a Node.js module for AES encryption/decryption.
+ Requirements:
+ 1.  Create a new file, e.g., `lib/crypto.js`.
+ 2.  Require the built-in `node:crypto` module.
+ 3.  Read a master encryption key from the environment variable `ENCRYPTION_KEY`. Throw an error on startup if it's missing or too short (e.g., less than 32 characters for AES-256).
+ 4.  Export two functions:
+     -   `encrypt(text)`:
+         -   Generates a random Initialization Vector (IV) (16 bytes for AES).
+         -   Creates an AES-256-CBC cipher using the `ENCRYPTION_KEY` and the generated IV.
+         -   Encrypts the input `text`.
+         -   Returns a string combining the IV and the encrypted text (e.g., `iv.toString('hex') + ':' + encrypted.toString('hex')`).
+     -   `decrypt(text)`:
+         -   Takes the combined string from `encrypt`.
+         -   Splits the string by `:` to get the IV hex and encrypted text hex.
+         -   Creates an AES-256-CBC decipher using the `ENCRYPTION_KEY` and the retrieved IV (convert hex back to buffer).
+         -   Decrypts the encrypted text.
+         -   Returns the original decrypted string.
+ 5.  Handle potential errors during encryption/decryption (e.g., invalid input format for decrypt).
+ 6.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Create `test/crypto.test.js` using `tape`.
+ -   Set a dummy `ENCRYPTION_KEY` environment variable for the test process.
+ -   Test case 1: Encrypt a sample string. Decrypt the result. Assert the decrypted value matches the original sample.
+ -   Test case 2: Test `decrypt` with invalid input (e.g., wrong format, incorrect key implicitly). Assert it throws or returns an error/null.
+ -   Test startup check: Ensure the module throws an error if `ENCRYPTION_KEY` is not set or invalid when required.
+ -   Ensure tests run via `npm test`. 
```

---



---

Creating `docs/prompts/14.md` with Prompt 14 content.


---

```diff
- 
+ Task: Add the `encryptedSshKey` field to the Repository schema.
+ Requirements:
+ 1.  Modify `models/Repository.js` (from Prompt 10).
+ 2.  Add a new field to the `repositorySchema`:
+     -   `encryptedSshKey`: { type: String } // Not required initially
+ 3.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Modify `test/repository.model.test.js` (from Prompt 10).
+ -   Test creating/updating a repository document with an `encryptedSshKey` value. Assert the value is stored and retrieved correctly.
+ -   Ensure tests run via `npm test`. 
```

---



---

Creating `docs/prompts/15.md` with Prompt 15 content.


---

```diff
- 
+ Task: Modify the `/add-repo` command to accept, encrypt, and store an SSH private key attachment.
+ Requirements:
+ 1.  Modify the `/add-repo` slash command registration (Prompt 4) to add a required `attachment` option named `ssh_key`.
+ 2.  Modify the `/add-repo` command handler (Prompt 5):
+     -   After permission checks, retrieve the `ssh_key` attachment option from the interaction (`interaction.options.getAttachment('ssh_key')`).
+     -   Check the attachment's content type (e.g., `text/plain` or common key file types, though validation might be loose initially) and size if needed. Reply with an error if invalid.
+     -   Fetch the attachment content using its URL (`attachment.url`). Use `node-fetch` or Node's built-in `fetch` (v18+). Handle fetch errors.
+     -   Read the fetched content as text (the private key).
+     -   Import the `encrypt` function (Prompt 13). Encrypt the key text.
+     -   When saving/updating the `Repository` document, store the encrypted key string in the `encryptedSshKey` field.
+     -   Update the confirmation message to indicate the key was received and stored securely.
+ 3.  Add `node-fetch` if Node version < 18.
+ 4.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Modify `test/add-repo-command.test.js`.
+ -   Set a dummy `ENCRYPTION_KEY`.
+ -   Mock the `interaction` object, including `options.getAttachment` to return a mock attachment object with a URL.
+ -   Mock `fetch` to return a fake SSH key string when called with the mock URL.
+ -   Mock the `encrypt` function or use the real one.
+ -   Assert that the `Repository` model's save/update method is called with the correctly encrypted key data.
+ -   Test error handling for fetch failures and invalid attachments.
+ -   Ensure tests run via `npm test`. 
```

---



---

Creating `docs/prompts/16.md` with Prompt 16 content.


---

```diff
- 
+ Task: Create Node.js functions for securely writing and deleting temporary SSH key files. (Deferring ownership/permissions until Docker setup).
+ Requirements:
+ 1.  Create a new file, e.g., `lib/secureKeys.js`.
+ 2.  Require built-in `node:fs/promises` and `node:path`.
+ 3.  Define a base directory for repositories (e.g., `/repos` or `process.cwd() + '/repos'` for local testing). Read from env var `REPO_BASE_DIR` if available, otherwise use a default.
+ 4.  Export an async function `writeTempKey({ repoName, keyContent })`:
+     -   Construct the target directory path: `path.join(baseDir, repoName, '.ssh')`.
+     -   Construct the target file path: `path.join(targetDir, 'id_rsa')`.
+     -   Ensure the target directory exists using `fs.mkdir(targetDir, { recursive: true })`.
+     -   Write the `keyContent` to the target file path using `fs.writeFile`. Set mode `0o600`.
+     -   Return the full path to the written key file.
+ 5.  Export an async function `deleteTempKey({ repoName })`:
+     -   Construct the target file path as above.
+     -   Delete the file using `fs.unlink`. Handle errors if the file doesn't exist (ignore).
+     -   Optionally: attempt to remove the `.ssh` directory if empty (`fs.rmdir`), but handle errors gracefully if not empty or non-existent.
+ 6.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Create `test/secureKeys.test.js` using `tape`.
+ -   Use a temporary directory for testing (e.g., using `os.tmpdir()` and a unique subdirectory). Set `REPO_BASE_DIR` env var for the test.
+ -   Test `writeTempKey`: Call it, assert the file is created in the correct temp location with the correct content and 600 permissions (check `fs.stat`).
+ -   Test `deleteTempKey`: Call `writeTempKey` then `deleteTempKey`. Assert the file is deleted. Call `deleteTempKey` again, assert no error occurs.
+ -   Clean up the temporary directory after tests.
+ -   Ensure tests run via `npm test`. 
```

---



---

Creating `docs/prompts/17.md` with Prompt 17 content.


---

```diff
- 
+ Task: Decrypt the SSH key, write it temporarily, and pass GIT_SSH_COMMAND to the Python wrapper.
+ Requirements:
+ 1.  Modify `lib/pythonWrapper.js`'s `invokeAiderWrapper` function (from Prompt 12):
+     -   Update signature to accept `invokeAiderWrapper({ prompt, contextFiles, repoConfig })`, where `repoConfig` is the full repository document object from the DB.
+     -   Import `decrypt` (Prompt 13) and `writeTempKey`, `deleteTempKey` (Prompt 16).
+     -   Define `repoName` (e.g., derive from `repoConfig.repoUrl` or add a `repoName` field to the schema later). For now, maybe use `repoConfig._id.toString()`.
+     -   If `repoConfig.encryptedSshKey` exists:
+         -   Call `decrypt` to get the key content. Handle errors.
+         -   Call `writeTempKey` with the `repoName` and decrypted key. Store the returned key file path.
+         -   Construct the `GIT_SSH_COMMAND` string: `"ssh -i ${keyFilePath} -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"`.
+         -   Add `GIT_SSH_COMMAND` to the `env` option passed to `child_process.spawn`. Make sure to merge with `process.env` so other variables are inherited.
+     -   Wrap the `spawn` call and the waiting for it in a `try...finally` block.
+     -   In the `finally` block, if a key was written, call `deleteTempKey({ repoName })`. Ensure deletion happens even if `spawn` or the script fails.
+ 2.  Modify the `@mention` handler (Prompt 8):
+     -   When a repository document is found, pass the *entire document* (`repoConfig`) to `invokeAiderWrapper`, not just context files.
+ 3.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Modify `test/pythonWrapper.test.js`.
+ -   Set dummy `ENCRYPTION_KEY` and `REPO_BASE_DIR`.
+ -   Create a mock `repoConfig` object including an `encryptedSshKey` (encrypt a dummy key).
+ -   Mock `writeTempKey` and `deleteTempKey`.
+ -   Call `invokeAiderWrapper` with the mock config.
+ -   Mock `child_process.spawn`. Assert it's called with the correct `env` option containing the `GIT_SSH_COMMAND` pointing to the expected temp key path.
+ -   Assert `writeTempKey` is called before `spawn`.
+ -   Assert `deleteTempKey` is called after `spawn` finishes/errors (mock `spawn` to simulate exit/error).
+ -   Ensure tests run via `npm test`. Clean up temp files/dirs. 
```

---



---

Creating `docs/prompts/18.md` with Prompt 18 content.


---

```diff
- 
+ Task: Create an initial Dockerfile for the application.
+ Requirements:
+ 1.  Create a `Dockerfile` in the project root.
+ 2.  Use an official Node.js base image that also includes Python 3 (e.g., `node:XX-slim` might need Python installed, or find a combined image like `node:XX-bullseye`). Choose appropriate versions.
+ 3.  Install necessary OS packages: `git`, `sudo`, `python3`, `python3-pip`, `tree`.
+ 4.  Set up a working directory (e.g., `/app`).
+ 5.  Copy `package.json` and `package-lock.json`.
+ 6.  Run `npm ci --only=production` to install Node.js dependencies.
+ 7.  Create a `requirements.txt` file listing Python dependencies: `aider-chat`.
+ 8.  Copy `requirements.txt`.
+ 9.  Run `pip3 install --no-cache-dir -r requirements.txt`.
+ 10. Copy the rest of the application code (including `aider_wrapper.py`).
+ 11. Expose any necessary port (though the bot doesn't listen directly, maybe relevant later).
+ 12. Define the default command `CMD ["node", "index.js"]`.
+ Testing:
+ -   Build the Docker image: `docker build -t discord-aider-bot .`
+ -   Assert the build completes successfully.
+ -   (Manual) Run the container with necessary env vars (`DISCORD_TOKEN`, `MONGODB_URI`, `ENCRYPTION_KEY`). Check logs to see if the bot connects to Discord and MongoDB (it won't fully work yet due to missing users/permissions/dirs, but basic startup should function). 
```

---



---

Creating `docs/prompts/19.md` with Prompt 19 content.


---

```diff
- 
+ Task: Modify the Dockerfile to create users and configure sudo.
+ Requirements:
+ 1.  Modify the `Dockerfile` (from Prompt 18):
+ 2.  Before copying application code:
+     -   Create a non-root group and user `appuser` (`groupadd -r appuser && useradd -r -g appuser -m -d /app -s /bin/bash appuser`). `/app` will be its home.
+     -   Create a group `coders`.
+     -   Create a pool of `coderX` users (e.g., `coder1` through `coder5`) belonging to the `coders` group, with home directories under `/repos` (e.g., `/repos/coder1`). Use a loop: `for i in $(seq 1 5); do useradd -r -g coders -m -d /repos/coder$i -s /bin/bash coder$i; done`.
+     -   Create the base `/repos` directory and set permissions allowing `appuser` to create subdirs later (`mkdir /repos && chown appuser:appuser /repos && chmod 755 /repos`). Or adjust permissions after creating coder homes.
+     -   Install `sudo` if not already done.
+     -   Configure passwordless `sudo` for `appuser`. Create a file in `/etc/sudoers.d/` (e.g., `appuser-privs`):
+         ```
+         # Allow appuser to run specific commands as coderX users
+         appuser ALL=(coder1,coder2,coder3,coder4,coder5) NOPASSWD: /usr/bin/python3 /app/aider_wrapper.py *
+         appuser ALL=(coder1,coder2,coder3,coder4,coder5) NOPASSWD: /usr/bin/git *
+         appuser ALL=(coder1,coder2,coder3,coder4,coder5) NOPASSWD: /bin/rm *
+         appuser ALL=(coder1,coder2,coder3,coder4,coder5) NOPASSWD: /bin/mkdir *
+         appuser ALL=(coder1,coder2,coder3,coder4,coder5) NOPASSWD: /bin/chown *
+         appuser ALL=(coder1,coder2,coder3,coder4,coder5) NOPASSWD: /bin/chmod *
+         # Add ls and tree if needed for commands
+         appuser ALL=(coder1,coder2,coder3,coder4,coder5) NOPASSWD: /bin/ls *
+         appuser ALL=(coder1,coder2,coder3,coder4,coder5) NOPASSWD: /usr/bin/tree *
+         ```
+         *Ensure paths to executables (`python3`, `git`, etc.) are correct for the base image.* Use `which git`, etc. inside a running container to verify.
+     -   Ensure the sudoers file has correct permissions (`chmod 0440 /etc/sudoers.d/appuser-privs`).
+ 3.  After copying code and setting up dependencies:
+     -   Change ownership of the `/app` directory to `appuser:appuser` (`chown -R appuser:appuser /app`).
+     -   Switch the user: `USER appuser`.
+     -   Set the `WORKDIR /app`.
+ 4.  The `CMD` remains the same.
+ Testing:
+ -   Rebuild the Docker image: `docker build -t discord-aider-bot .` Assert success.
+ -   Run the container interactively: `docker run -it --rm --user=appuser discord-aider-bot /bin/bash`.
+ -   Inside the container (as `appuser`):
+     -   Verify `whoami` returns `appuser`.
+     -   Verify `sudo -u coder1 whoami` returns `coder1`.
+     -   Verify `sudo -u coder1 /usr/bin/git --version` works.
+     -   Verify `sudo -u coder1 /bin/rm --version` works.
+     -   Verify `sudo -u coder1 touch /tmp/test` fails (as `touch` is not in sudoers).
+     -   Verify `/repos` exists and `coderX` home directories exist inside. 
```

---



---

Creating `docs/prompts/20.md` with Prompt 20 content.


---

```diff
- 
+ Task: Assign a `coderX` user when adding a repository and store it.
+ Requirements:
+ 1.  Modify `models/Repository.js` (from Prompt 14):
+     -   Add a new field `assignedUserId`: { type: String }. Add an index if needed.
+ 2.  Modify the `/add-repo` command handler (from Prompt 15):
+     -   Define the pool of available user IDs (e.g., `['coder1', 'coder2', ..., 'coder5']`). This could be hardcoded or read from config/env.
+     -   Before saving the new repository document, query the `repositories` collection to find which `assignedUserId`s are already in use.
+     -   Select the first available ID from the pool that is not currently in use. If all are in use, reply with an error ("Maximum repository limit reached.").
+     -   Store the selected ID in the `assignedUserId` field of the new repository document.
+     -   Update the confirmation message to include the assigned user ID (for debugging/info).
+ 3.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Modify `test/add-repo-command.test.js`.
+ -   Use in-memory MongoDB.
+ -   Test adding the first repo: Assert `assignedUserId` is 'coder1' (or the first in the pool).
+ -   Seed the DB with repos assigned to 'coder1', 'coder2'. Test adding another: Assert `assignedUserId` is 'coder3'.
+ -   Seed the DB with all user IDs assigned. Test adding another: Assert an error reply is sent and no new document is created.
+ -   Ensure tests run via `npm test`. 
```

---

Done, Big D. Files `docs/prompts/11.md` through `docs/prompts/20.md` have been created with their respective prompt content.

---

_**User**_

now do it for 

---

_**Assistant**_



---

Okay Big D, let's get prompts 21 through 37 into their files.

Creating `docs/prompts/21.md` with Prompt 21 content.


---

```diff
- 
+ Task: Execute the Python wrapper using `sudo` as the assigned `coderX` user and set the correct working directory. Adjust secure key handling for permissions.
+ Requirements:
+ 1.  Modify `lib/secureKeys.js` (from Prompt 16):
+     -   Update `writeTempKey` signature: `writeTempKey({ repoName, keyContent, ownerUserId })`.
+     -   Update `deleteTempKey` signature: `deleteTempKey({ repoName, ownerUserId })`. (Though owner might not be needed for delete if `appuser` can sudo rm).
+     -   Inside `writeTempKey`, after writing the file with mode 600:
+         -   Use `child_process.execFileSync` or `spawnSync` to run `sudo -u ${ownerUserId} chown ${ownerUserId}:${ownerUserId} ${targetFilePath}`.
+         -   Use `child_process.execFileSync` or `spawnSync` to run `sudo -u ${ownerUserId} chmod 600 ${targetFilePath}` (might be redundant but ensures).
+         -   Handle errors from these `sudo` commands.
+     -   *Alternative:* If `appuser` has sudo rights to write *as* `coderX`, could potentially use `sudo -u ${ownerUserId} dd of=${targetFilePath}` with stdin piping, but `chown/chmod` after writing as `appuser` is likely simpler.
+ 2.  Modify `lib/pythonWrapper.js`'s `invokeAiderWrapper` function (from Prompt 17):
+     -   Retrieve `assignedUserId` from the `repoConfig`.
+     -   Construct the repository path: `repoPath = path.join(baseDir, repoName)` (`baseDir` from Prompt 16). Ensure this directory will exist (Step 22 handles creation).
+     -   When calling `writeTempKey`, pass the `assignedUserId` as `ownerUserId`.
+     -   Modify the `spawn` call:
+         -   The command is now `sudo`.
+         -   Arguments are `['-u', assignedUserId, 'python3', '/app/aider_wrapper.py', '--prompt', prompt, ...]`.
+         -   Set the `cwd` option in `spawn` to `repoPath`.
+         -   Keep the `env` option for `GIT_SSH_COMMAND`.
+ 3.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Modify `test/secureKeys.test.js`: Update calls to include `ownerUserId`. Mock `child_process` to verify `sudo chown/chmod` commands are called correctly after file writing.
+ -   Modify `test/pythonWrapper.test.js`:
+     -   Provide a mock `repoConfig` including `assignedUserId`.
+     -   Assert `writeTempKey` is called with the correct `ownerUserId`.
+     -   Mock `child_process.spawn`. Assert it's called with `sudo -u <userId> python3 ...` and the correct `cwd` option set to the expected repo path.
+ -   These tests might require a Linux environment or careful mocking due to `sudo` and path assumptions.
+ -   Ensure tests run via `npm test`. 
```

---

Creating `docs/prompts/22.md` with Prompt 22 content.


---

```diff
- 
+ Task: Clone the repository using Git when `/add-repo` is invoked.
+ Requirements:
+ 1.  Modify the `/add-repo` command handler (from Prompt 20).
+ 2.  After assigning `assignedUserId` and before saving the `Repository` document (or perhaps after saving, but before replying success):
+     -   Import `decrypt` (Prompt 13), `writeTempKey`, `deleteTempKey` (Prompt 21), `path`, `fs/promises`, `child_process`.
+     -   Get `baseDir` (Prompt 16). Define `repoName` (e.g., from URL or ID). Construct `repoPath = path.join(baseDir, repoName)`.
+     -   Create the repository directory: `await fs.mkdir(repoPath, { recursive: true })`.
+     -   Run `sudo -u ${assignedUserId} chown ${assignedUserId}:${assignedUserId} ${repoPath}` using `execFileSync`.
+     -   Decrypt the SSH key (`repoConfig.encryptedSshKey`).
+     -   Call `writeTempKey({ repoName, keyContent, ownerUserId: assignedUserId })`. Store `keyFilePath`.
+     -   Construct `GIT_SSH_COMMAND` env var as in Prompt 17.
+     -   Execute the clone command: Use `spawn` or `execFile` for `sudo -u ${assignedUserId} git clone ${repoUrl} .`
+         -   Set the `cwd` to `repoPath`.
+         -   Pass the `GIT_SSH_COMMAND` in the `env` options (merged with `process.env`).
+         -   Capture `stdout` and `stderr`. Wait for completion.
+     -   Use a `try...finally` block around the clone operation.
+     -   In `finally`, call `deleteTempKey({ repoName, ownerUserId: assignedUserId })`.
+     -   If the `git clone` command fails (non-zero exit code or significant stderr), handle the error:
+         -   Log the error details (`stderr`).
+         -   Clean up: remove the created `repoPath` directory (`fs.rm(repoPath, { recursive: true, force: true })`).
+         -   Do *not* save the `Repository` document (if not already saved), or delete it if already saved.
+         -   Reply to the user with a specific error: "‚ùå Failed to clone repository. Please check the URL and SSH key permissions. Details logged."
+     -   If clone succeeds, proceed to save the `Repository` document (if not already saved) and reply with success.
+ 3.  Use standard.js style. Run `standard --fix`.
+ Testing:
+ -   Modify `test/add-repo-command.test.js`. This becomes more of an integration test.
+ -   Requires mocking `fs`, `child_process`, `decrypt`, `writeTempKey`, `deleteTempKey`.
+ -   Test success case: Mock `git clone` to exit 0. Assert `Repository.save` is called and success reply sent. Assert temp key is deleted. Assert repo dir and owner are set correctly.
+ -   Test clone failure case: Mock `git clone` to exit 1 with stderr. Assert `Repository.save` is *not* called (or doc is deleted), error reply is sent, temp key is deleted, repo dir is removed.
+ -   Use a test Git repository URL (can be fake).
+ -   Ensure tests run via `npm test`. 
```

---

Creating `docs/prompts/23.md` with Prompt 23 content.


---

```diff
- 
+ Task: Integrate `aider` in Wrapper: Modify the Python wrapper to initialize and run the actual `aider` Coder.
+ Requirements:
+ 1.  Modify `aider_wrapper.py` (from Prompt 12):
+ 2.  Import necessary components from `aider`: `from aider.coders import Coder` and `from aider.io import InputOutput`.
+ 3.  In the main execution block:
+     -   Parse arguments (`--prompt`, `--context-file`).
+     -   Initialize `io = InputOutput(yes=True)` for non-interactive mode.
+     -   Initialize the coder: `coder = Coder(main_model=None, io=io, fnames=context_files)` (replace `context_files` with the parsed list from `--context-file`. Use default model for now). Handle potential initialization errors.
+     -   Wrap the execution in a `try...except` block.
+     -   Inside `try`: Run the coder: `coder.run(with_message=prompt)` (use `with_message` instead of positional).
+     -   Determine success/failure based on whether an exception occurred.
+     -   Construct the JSON output object (defined in spec 6.5):
+         -   Set `overall_status` to "success" or "failure".
+         -   Set `error` to the exception message if failure, else `null`.
+         -   Populate `events` array:
+             -   Initially, add a single `{"type": "status_message", "content": "Aider run completed."}` on success or `{"type": "status_message", "content": "Aider run failed."}` on failure. More detailed events later.
+             -   Consider capturing `coder.io.tool_output` or similar for basic text output and add a `text_response` event if available.
+     -   Print the JSON object to stdout.
+     -   If an exception occurred, print the stack trace to stderr.
+ 4.  Update `requirements.txt` if specific `aider-chat` version is needed.
+ Testing:
+ -   Modify `test/aider_wrapper.test.js`.
+ -   These tests become harder as they involve the real `aider` library.
+ -   Option 1 (Mocking `aider`): Use Python's `unittest.mock` within the test setup (e.g., via a helper script called by Node) to mock `aider.coders.Coder` and `coder.run`. Test that `Coder` is initialized with correct args (`fnames`, `io`) and `coder.run` is called with the prompt. Assert the JSON output reflects mock success/failure.
+ -   Option 2 (Basic Integration): Run the script against a *minimal* test case. Provide a simple prompt and maybe a dummy context file. Assert the script exits cleanly (code 0) and produces valid JSON output (structure check), without necessarily validating `aider`'s specific behavior yet. This requires `aider-chat` to be installed where tests run.
+ -   Ensure tests run via `npm test`. 
```

---



---

Creating `docs/prompts/24.md` with Prompt 24 content.


---

```diff
- 
+ Task: Detect File Changes: Enhance the Python wrapper to detect file changes made by `aider` and include them in the output.
+ Requirements:
+ 1.  Modify `aider_wrapper.py` (from Prompt 23):
+ 2.  Requires `gitpython` library: Add `GitPython` to `requirements.txt` and install it (`pip install`).
+ 3.  Import `git`.
+ 4.  Before `coder.run()`:
+     -   Initialize `repo = git.Repo('.')` (assuming cwd is the repo root).
+     -   Get the set of currently tracked files known to Git: `initial_files = set(item.path for item in repo.index.iter_blobs())`.
+     -   Get the initial status/diff to detect modifications to tracked files: `initial_diff = repo.index.diff(None)` (unstaged changes). Store modified paths.
+ 5.  After `coder.run()` completes successfully:
+     -   Get the set of tracked files *after* the run: `final_files = set(item.path for item in repo.index.iter_blobs())`. This seems incorrect, need to check untracked/staged files too.
+     -   *Alternative Approach:* Use `repo.git.status('--porcelain')` before and after `coder.run`. Parse the output to determine added (`??`), deleted (` D`), modified (` M`), etc. files. This is likely more reliable.
+     -   Compare the before/after status.
+     -   Iterate through detected changes:
+         -   For modified/added files: Read the new content (`open(filepath).read()`). Generate a diff if possible/required by spec (`repo.git.diff('HEAD', filepath)` might work *after* staging, or compare content manually).
+         -   For deleted files: Note the filename.
+     -   In the JSON output's `events` array:
+         -   For each change, add a `file_change` event object:
+             ```json
+             {
+               "type": "file_change",
+               "filename": "path/relative/to/repo/root.py",
+               "change_type": "modified" | "added" | "deleted",
+               "content": "...", // Full new content for added/modified, null for deleted
+               "diff": "..."   // Standard diff output for modified, null otherwise
+             }
+             ```
+ 6.  Refine the `overall_status` based on whether changes occurred. Add status messages.
+ Testing:
+ -   Modify `test/aider_wrapper.test.js`. This requires a test environment with a dummy Git repository.
+ -   Setup: Before running the wrapper script in the test, create a temporary directory, initialize git (`git init`), add and commit a file (`dummy.txt`).
+ -   Test case 1 (Modification): Run the wrapper script (mocking `coder.run` to simulate modifying `dummy.txt`). Assert the output JSON contains a `file_change` event for `dummy.txt` with `change_type: "modified"`, and includes `content` and/or `diff`.
+ -   Test case 2 (Addition): Mock `coder.run` to simulate creating a new file `new.txt`. Assert a `file_change` event for `new.txt` with `change_type: "added"` and `content`.
+ -   Test case 3 (Deletion): Mock `coder.run` to simulate deleting `dummy.txt`. Assert a `file_change` event for `dummy.txt` with `change_type: "deleted"`.
+ -   Clean up the temporary git directory.
+ -   Ensure tests run via `npm test`. 
```

---



---

Creating `docs/prompts/25.md` with Prompt 25 content.


---

Cancelled

---



---



---

